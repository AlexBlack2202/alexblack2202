<!DOCTYPE HTML>

<html>

    <head>

	<script defer="defer" async="async" src="https://www.googleoptimize.com/optimize.js?id=OPT-52RT2BV"></script>
        <script type="application/ld+json">
    {
        "@context" : "http://schema.org",
        "@type" : "BlogPosting",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "/"
        },
        "articleSection" : "blog",
        "name" : "Reinforcement Learning và tictactoe",
        "headline" : "Reinforcement Learning và tictactoe",
        "description" : "Trong khi trong các phương pháp lý thuyết trò chơi nói chung, ví dụ thuật toán min-max, thuật toán luôn giả định chúng ta có một đối thủ hoàn hảo, công việc phải thực hiện là tối đa hóa phần thưởng của mình và giảm thiểu phần thưởng của đối thủ ( tối đa hóa điểm của mình và tối thiểu hóa điểm của đối thủ), trong học củng cố, chúng ta không cần giả định đối thủ của chúng ta là 1 thiên tài xuất chúng, nhưng chung ta vẫn thu được mô hình với kết quả rất tốt.",
        "inLanguage" : "en",
        "author" : "alexblack2202@gmail.comPhạm Duy Tùng",
        "creator" : "alexblack2202@gmail.comPhạm Duy Tùng",
        "publisher": "alexblack2202@gmail.comPhạm Duy Tùng",
        "accountablePerson" : "alexblack2202@gmail.comPhạm Duy Tùng",
        "copyrightHolder" : "alexblack2202@gmail.comPhạm Duy Tùng",
        "copyrightYear" : "2020",
        "datePublished": "2020-12-27 00:19:00 &#43;0300 &#43;0300",
        "dateModified" : "2020-12-27 00:19:00 &#43;0300 &#43;0300",
        "url" : "/blog/2020-12-26---tic-tac-toe/",
        "wordCount" : "2244",
        "keywords" : [ "python","tetris","opencv","Blog" ]
    }
    </script>
        
            
                <title>Reinforcement Learning và tictactoe</title>
            
        

        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        
		<meta name="generator" content="Phạm Duy Tùng" />
        <meta property="fb:pages" content="1244186728962161" />
<meta name='dmca-site-verification' content='Uk5YSGpDdzE4c0xnV0FaM3lEQXpLd0Exa29OQXFIT2d3Y05OM0daMmFlVT01' />
        
  
    
  

  

  
  
  
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content='/favicon/mstile.png'>
  <meta name="application-name" content="Phạm Duy Tùng Machine Learning Blog">
  <meta name="msapplication-tooltip" content="Blog ML của Phạm Duy Tùng và Đặng Thị Hằng">
   
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">



        
            <meta name="author" content="Phạm Duy Tùng">
        
        
            <meta name="description" content="Trong khi trong các phương pháp lý thuyết trò chơi nói chung, ví dụ thuật toán min-max, thuật toán luôn giả định chúng ta có một đối thủ hoàn hảo, công việc phải thực hiện là tối đa hóa phần thưởng của mình và giảm thiểu phần thưởng của đối thủ ( tối đa hóa điểm của mình và tối thiểu hóa điểm của đối thủ), trong học củng cố, chúng ta không cần giả định đối thủ của chúng ta là 1 thiên tài xuất chúng, nhưng chung ta vẫn thu được mô hình với kết quả rất tốt.">
        

        <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Reinforcement Learning và tictactoe"/>
<meta name="twitter:description" content="Trong khi trong các phương pháp lý thuyết trò chơi nói chung, ví dụ thuật toán min-max, thuật toán luôn giả định chúng ta có một đối thủ hoàn hảo, công việc phải thực hiện là tối đa hóa phần thưởng của mình và giảm thiểu phần thưởng của đối thủ ( tối đa hóa điểm của mình và tối thiểu hóa điểm của đối thủ), trong học củng cố, chúng ta không cần giả định đối thủ của chúng ta là 1 thiên tài xuất chúng, nhưng chung ta vẫn thu được mô hình với kết quả rất tốt."/>
<meta name="twitter:site" content="@example"/>

        <meta property="og:title" content="Reinforcement Learning và tictactoe" />
<meta property="og:description" content="Trong khi trong các phương pháp lý thuyết trò chơi nói chung, ví dụ thuật toán min-max, thuật toán luôn giả định chúng ta có một đối thủ hoàn hảo, công việc phải thực hiện là tối đa hóa phần thưởng của mình và giảm thiểu phần thưởng của đối thủ ( tối đa hóa điểm của mình và tối thiểu hóa điểm của đối thủ), trong học củng cố, chúng ta không cần giả định đối thủ của chúng ta là 1 thiên tài xuất chúng, nhưng chung ta vẫn thu được mô hình với kết quả rất tốt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/blog/2020-12-26---tic-tac-toe/" /><meta property="article:published_time" content="2020-12-27T00:19:00&#43;03:00"/>
<meta property="article:modified_time" content="2020-12-27T00:19:00&#43;03:00"/>

        <meta property="og:image" content="//images/logo.png">
        <meta property="og:image:type" content="image/png">
        <meta property="og:image:width" content="512">
        <meta property="og:image:height" content="512">
        
<meta itemprop="name" content="Reinforcement Learning và tictactoe">
<meta itemprop="description" content="Trong khi trong các phương pháp lý thuyết trò chơi nói chung, ví dụ thuật toán min-max, thuật toán luôn giả định chúng ta có một đối thủ hoàn hảo, công việc phải thực hiện là tối đa hóa phần thưởng của mình và giảm thiểu phần thưởng của đối thủ ( tối đa hóa điểm của mình và tối thiểu hóa điểm của đối thủ), trong học củng cố, chúng ta không cần giả định đối thủ của chúng ta là 1 thiên tài xuất chúng, nhưng chung ta vẫn thu được mô hình với kết quả rất tốt.">


<meta itemprop="datePublished" content="2020-12-27T00:19:00&#43;03:00" />
<meta itemprop="dateModified" content="2020-12-27T00:19:00&#43;03:00" />
<meta itemprop="wordCount" content="2244">



<meta itemprop="keywords" content="python,tetris,opencv," />

        

        
            
        

        
        
          
			 <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">


          
            
        

        
            
                
            
        


  
    
    <link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/styles/xcode.min.css' rel='stylesheet' type='text/css' />
  


      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-114911596-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

	  <style>
	  
	  body{
font-family: Helvetica,Arial,sans-serif;
}

.card{
	margin-bottom: 10px;
}

#disqus_thread{
padding: 0 5px;
}

.item-header{
padding: 0;
}

.single-content-img{
width: 100%;
    max-height: 450px !important;
    background-size: cover;
    display: block;
    background-position: center;
}

.thumbnail {
    position: relative;
}

.caption {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
	background: rgba(0, 0, 0, 0.25);
	text-align:left;
}

.caption .title{
	font-size: 1.6em;
    line-height: 1.4em;
    top: 0;
	margin-left:20px;
	margin-top:20px;
	
}

.caption .title-caption{
margin-left:10px;
}

#content p{
text-align: justify;
}

#content img{
	display: block;
    margin-left: auto;
margin-right: auto;
max-width:98%;
}

img + strong {
    font-style: normal;
    display: inherit;
    text-align: center;
}
.img-news{
max-height:150px;
width:100%;
}

.news-tittle{
	padding-top:15px;
	text-align:justify;
}

.author{
	color: orange;
}
.author-inline{
	color: orange;
}

.adv{
height:18px;
}


.hljs{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;}
.titledetail {
    display: block;
    overflow: hidden;
    line-height: 53px;
    font-size: 45px;
    font-family: 'Roboto Condensed',sans-serif;
    font-weight: 600;

    margin: auto;
	padding: 0 ;
}

.newsrelate {
    display: block;
    overflow: hidden;
	 list-style:none;
}
a ,a:hover{
    text-decoration: none;
}
.newsrelate li {
    float: left;
    overflow: hidden;
    width: 30%;
    margin-left: 2.5%;
    margin-bottom: 15px;
}

.newsrelate li a {
    display: block;
    overflow: hidden;
}

.userdetail {
    display: block;
    overflow: hidden;
    margin: 0 10px 0 0;
    padding: 15px 0;
}
.newsrelate li h3 {
    display: block;
    overflow: hidden;
    line-height: 1.3em;
    font-size: 16pt;
    line-height: 22px;
    font-weight: 300;
    font-family: Arial,Helvetica,sans-serif;
    width: auto;
    margin: 5px auto;
}

.titlerelate {
    overflow: hidden;
    font-size: 18px;
    font-weight: 600;
    font-family: 'Roboto Condensed',sans-serif;
    line-height: 32px;
    text-transform: uppercase;
}
article .captionnews {
    color: #999;
    font-size: 14px;
    font-style: italic;
    padding: 10px;
    text-align: center;
    margin-bottom: 15px;
}

.bgtrans h1 {
    display: block;
    overflow: hidden;
    font-size: 45px;
    line-height: 55px;
    margin: auto;
    left: 0;
    right: 0;
    bottom: 50px;
    font-family: 'Roboto Condensed',sans-serif;
    font-weight: 600;
}

.bgcover {
    display: block;
    overflow: hidden;
    height: 450px;
    background: no-repeat center center;
    -webkit-background-size: cover;
    -moz-background-size: cover;
    -o-background-size: cover;
    background-size: cover;
    position: relative;
    margin-bottom: -65px;
}
.bgcover .bgtrans .userdetail {
    width: 800px;
    margin: auto;
    position: absolute;
    left: 0;
    right: 0;
    bottom: 10px;
}
.userdetail {
    display: block;
    overflow: hidden;
    margin: 0 10px 0 0;
    padding: 15px 0;
}

.amlich{border-collapse:collapse;font-size:14px;font-family:Roboto,sans-serif}.calendar{font-size:12px}.calendar td{background-color:#e9eff3}.calendar-month{background-color:#1e8cbe!important;color:#fff;text-shadow:0 0 3px #000;padding:6px;font-weight:700;text-transform:uppercase;font-size:14px!important}.amlich-tennam{text-align:center;font-weight:700;color:#000;background-color:#ccc;font-size:14px;font-family:Roboto,sans-serif}.amlich .calendar-month,.amlich .calendar-b-left,.amlich .calendar-b-right{text-align:center;padding:4px 0;font-size:11px}.amlich .calendar-day{text-align:center;font-weight:700}.amlich .calendar-day .day-num{font-size:80px;font-family:Roboto,sans-serif;line-height:100%;color:#31708f}.amlich .lunar-day-num{font-size:44px;line-height:100%;font-weight:700;color:#3c763d}.amlich .calendar-holiday,.amlich .calendar-hoangdao{padding:0 4px 4px;font-size:11px;text-align:center}.amlich .calendar-holiday{color:#a94442;font-weight:700}.amlich a{text-decoration:none;color:#fff}.amlich a:hover{color:red}.amlich .tenthang,.amlich .navi-l,.amlich .navi-r{text-align:center;padding:6px;background-color:#1e8cbe;color:#fff;font-weight:700}.amlich .tenthang{text-shadow:0 0 3px #000}.amlich .navi-l{font-size:12px}.amlich .navi-r{font-size:12px}.amlich .ngaytuan{text-align:center;color:#303;background-color:#ddd;padding:3px;width:14.286%;font-size:10px;font-weight:700}.amlich .ngaythang,.amlich .homnay,.amlich .tet,.amlich .leam,.amlich .leduong{cursor:pointer;border-bottom:solid 1px #eee;padding:3px;width:14.286%}.amlich .ngaythang div,.amlich .homnay div,.amlich .tet div,.amlich .leam div,.amlich .leduong div{line-height:110%}.amlich .ngaythang{color:#5a5c5b}.amlich tr:nth-child(odd) td.ngaythang:nth-child(odd){background-color:#f9f9f9}.amlich tr:nth-child(odd) td.ngaythang:nth-child(even){background-color:#fff}.amlich tr:nth-child(even) td.ngaythang:nth-child(odd){background-color:#fff}.amlich tr:nth-child(even) td.ngaythang:nth-child(even){background-color:#f9f9f9}.amlich tr td.ngaythang:hover{background-color:#f5f5f5!important}.amlich .homnay{background-color:#fcf8e3;color:#fff}.amlich .homnay:hover{background-color:#faf2cc}.amlich .tet{background-color:#f2dede}.amlich .tet:hover{background-color:#ebcccc}.amlich .leam{background-color:#d9edf7}.amlich .leam:hover{background-color:#c4e3f3}.amlich .leduong{background-color:#dff0d8}.amlich .leduong:hover{background-color:#d0e9c6}.amlich .am{text-align:right;font-size:75%;color:#554c00}.amlich .am2{text-align:right;font-size:75%;color:#337ab7;font-weight:700}.amlich .t2t6{text-align:left;color:#5a5c5b;font-weight:700}.amlich .t7{font-weight:700;text-align:left;color:blue}.amlich .cn{font-weight:700;text-align:left;color:red}
	  </style>

    </head>
    <body class="text-dark bg-light">
<script  async defer>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '1546237302193677',
      xfbml      : true,
      version    : 'v5.0'
    });
    FB.AppEvents.logPageView();
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "https://connect.facebook.net/en_US/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>
<div id="fb-root"></div>
<script async defer crossorigin="anonymous" src="https://connect.facebook.net/vi_VN/sdk.js#xfbml=1&version=v5.0&appId=1853483258232756&autoLogAppEvents=1"></script>
      
      

    
    
<header id="header"  style="background: #790014; color: hsla(0,0%,100%,1);">
<div class="container">
    <nav class="navbar navbar-expand-md navbar-dark">
	
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav mr-auto">
            
                <li class="nav-item">
                    <a class='nav-link' href="/blog">
                            <i class="fa fa-home active">&nbsp;</i>Home
                    </a>
                </li>
            
        </ul>
    </nav>
    </div></div>
</header>


   
    
	<div class="container">
	<div class="adv"></div>
	<div class="row">
    <main role="main"  class="col-md-9 border-left border-right" >
	
        
        
          


        
		 <div class="header">
           
		<div class="bgtrans">
		 <h1 class="titledetail">Reinforcement Learning và tictactoe</h1>
		<div class="userdetail">
			 
			  <time class="published" 
            datetime='2020-12-27'>
            27/12/2020</time>
		 - 
			   <span class="author">Phạm Duy Tùng</span>
			   
			</div>	
		
			</div>
			</div>
  <div class="fb-like" data-share="true"  data-width="800"  data-show-faces="true">
</div>
			
		
		
			 
            
        
       



  

  
 
  <div style="    margin: 0;
    border-bottom: 1px dotted #d9d9d9;
    padding-bottom: 20px;"></div>
  <div id="content">
    

<h1 id="advantages-of-reinforcement-learning">Advantages of Reinforcement Learning</h1>

<p>Trong khi trong các phương pháp lý thuyết trò chơi nói chung, ví dụ thuật toán min-max, thuật toán luôn giả định chúng ta có một đối thủ hoàn hảo, công việc phải thực hiện là tối đa hóa phần thưởng của mình và giảm thiểu phần thưởng của đối thủ ( tối đa hóa điểm của mình và tối thiểu hóa điểm của đối thủ), trong học củng cố, chúng ta không cần giả định đối thủ của chúng ta là 1 thiên tài xuất chúng, nhưng chung ta vẫn thu được mô hình với kết quả rất tốt.</p>

<p>Bằng cách coi đối thủ là một phần của môi trường mà chúng ta có thể tương tác, sau một số lần lặp lại nhất định, đối thủ có thể lập kế hoạch trước mà không cần chúng ta phải làm gì cả. Ưu điểm của phương pháp này là giảm số lượng không gian tìm kiếm và giảm số phép toán suy luận phải thực hiện, nhưng nó có thể đạt được kỹ năng hiện đại chỉ bằng cách thử và học.</p>

<p>Trong bài viết này, chúng ta sẽ làm các công việc sau:</p>

<ul>
<li><p>Thứ nhất, huấn luyện mô hình cho 2 máy đấu với nhau mà thu được các trọng số cần thiết.</p></li>

<li><p>Thứ hai, cho người đánh với máy</p></li>
</ul>

<p>Để hình thành bài toán học củng cố Reinforcement Learning , chúng ta cần  phải xác định rõ 3 thành phần chính:</p>

<ul>
<li><p>State</p></li>

<li><p>Action</p></li>

<li><p>Reward</p></li>
</ul>

<p>Với:</p>

<p>State chính là bàn cờ với các nước đi của các người chơi. Chúng ta sẽ tạo một bàn cờ có kích thước 3x3, giá trị của mỗi ô cờ đều là 0. Vị trí người chơi 1 đặt quân sẽ được gán là 1. Vị trí người chơi 2 đặt quân sẽ được gán là -1.</p>

<p>Action là vị trí người chơi sẽ đi quân khi biết state hiện tại (nghĩa là biết đối thủ đi nước nào, và có những nước nào hiện đang trên bàn cờ).</p>

<p>Reward: mang giá trị 0 hoặc 1. Khi kết thúc game sẽ trả về giá trị cho reward.</p>

<p>Ở phần dưới đây, mình sẽ note lại code và sẽ comment trong code để cho rõ ý</p>

<h1 id="thiết-lập-bàn-cờ">Thiết lập bàn cờ</h1>

<h2 id="khởi-tạo-bàn-cờ">Khởi tạo bàn cờ</h2>

<pre><code class="language-python">
def __init__(self, p1, p2):
        self.board = np.zeros((BOARD_ROWS, BOARD_COLS))
        self.p1 = p1
        self.p2 = p2
        self.isEnd = False
        self.boardHash = None
        # init p1 plays first
        self.playerSymbol = 1

</code></pre>

<p>Chúng ta sẽ tạo một bàn cờ có kích thước 3x3, 2 biến người chơi. Người 1 là người chơi đầu tiên.</p>

<pre><code class="language-python">
# Trả về danh sách các nước có thể đi
def availablePositions(self):
        positions = []
        for i in range(BOARD_ROWS):
            for j in range(BOARD_COLS):
                if self.board[i, j] == 0:
                    positions.append((i, j))  # need to be tuple
        return positions

# Cập nhật lại lên bàn cờ vị trí của người chơi đặt quân

def updateState(self, position):
    self.board[position] = self.playerSymbol
    # switch to another player
    self.playerSymbol = -1 if self.playerSymbol == 1 else 1
    
</code></pre>

<h2 id="kiểm-tra-reward">Kiểm tra Reward</h2>

<p>Sau mỗi nước đi của các kỳ thủ, chúng ta cần 1 hàm để kiểm tra xem kỳ thủ thắng hay thua và trả về kết quả cho reward như đề cập ở trên</p>

<pre><code class="language-python">
def winner(self):

    # Kiểm tra theo dòng
    
    for i in range(BOARD_ROWS):
        if sum(self.board[i, :]) == 3:
            self.isEnd = True
            return 1
        if sum(self.board[i, :]) == -3:
            self.isEnd = True
            return -1
    # kiểm tra theo cột
    
    for i in range(BOARD_COLS):
        if sum(self.board[:, i]) == 3:
            self.isEnd = True
            return 1
        if sum(self.board[:, i]) == -3:
            self.isEnd = True
            return -1
            
    # kiểm tra theo đường chéo chính và theo đường chéo phụ
    
    diag_sum1 = sum([self.board[i, i] for i in range(BOARD_COLS)]) # đường chéo chính
    
    diag_sum2 = sum([self.board[i, BOARD_COLS - i - 1] for i in range(BOARD_COLS)]) # đường chéo phụ
    
    diag_sum = max(abs(diag_sum1), abs(diag_sum2)) # lấy trị tuyệt đối của các nước đi, nếu bằng 3 nghĩa là có người chơi chiến thắng
    
    if diag_sum == 3:
        self.isEnd = True
        if diag_sum1 == 3 or diag_sum2 == 3:
            return 1
        else:
            return -1

    # Kiểm tra xem còn nước đi hay không
    if len(self.availablePositions()) == 0:
        self.isEnd = True
        return 0
        
    # not end
    self.isEnd = False
    return None

# only when game ends
def giveReward(self):
    result = self.winner()
    # backpropagate reward
    if result == 1:
        self.p1.feedReward(1)
        self.p2.feedReward(0)
    elif result == -1:
        self.p1.feedReward(0)
        self.p2.feedReward(1)
    else:
        self.p1.feedReward(0.1)
        self.p2.feedReward(0.5)

</code></pre>

<p>Ở đây có một lưu ý. Khi cờ hòa thì chúng ta cũng xem rằng người đi trước thua, nên hệ số lúc cờ hòa sẽ là 0.1-0.5. Các bạn có thể thiết lập một giá trị khác, ví dụ 0.2-0.5 hoặc 0.5-0.5 tùy thích.</p>

<h1 id="thiết-lập-người-chơi">Thiết lập người chơi</h1>

<p>Người chơi cần có các phương thức sau:</p>

<ul>
<li><p>Chọn nước đi dựa trên trạng thái hiện tại của bàn cờ.</p></li>

<li><p>Lưu lại trạng thái của ván cờ.</p></li>

<li><p>Cập nhật lại giá trị trạng thái sau mỗi ván.</p></li>

<li><p>Lưu và load các trọng số lên.</p></li>
</ul>

<h2 id="khởi-tạo">Khởi tạo</h2>

<pre><code class="language-python">
def __init__(self, name, exp_rate=0.2):
        self.name = name
        self.states = []  # record all positions taken
        self.lr = 0.2
        self.exp_rate = exp_rate
        self.decay_gamma = 0.9
        self.states_value = {}  # state -&gt; value

</code></pre>

<h2 id="chọn-nước-đi">Chọn nước đi</h2>

<pre><code class="language-python">
def chooseAction(self, positions, current_board, symbol):
    randValue = np.random.uniform(0, 1)
    value_max = value = -999
    if  randValue&gt; self.exp_rate:
        
        for p in positions:
            next_board = current_board.copy()
            next_board[p] = symbol
            next_boardHash = self.getHash(next_board)
            value = -999 if self.states_value.get(next_boardHash) is None else self.states_value.get(next_boardHash)
            # print(&quot;value&quot;, value)
            if value &gt;= value_max:
                value_max = value
                action = p

    if  value_max == -999 :
        # take random action
        idx = np.random.choice(len(positions))
        action = positions[idx]
    
    # print(&quot;{} takes action {}&quot;.format(self.name, action))
    return action

</code></pre>

<h2 id="cập-nhật-trạng-thái">Cập nhật trạng thái</h2>

<p>Chúng ta sẽ cập nhật trạng thái với công thức sau</p>

<p>$$ V(S_t) = V(S<em>t) + \alpha [V(S</em>{t+1}) - V(S_t)]   $$</p>

<p>Diễn giải ra tiếng việt, giá trị của trạng thái tại thời điểm t bằng giá trị tại thời điểm hiện tại cộng với độ lệch của trạng thái hiện tại và trạng thái tiếp theo nhân với một hệ số học alpha.</p>

<pre><code class="language-python">
# at the end of game, backpropagate and update states value
def feedReward(self, reward):
        for st in reversed(self.states):
            if self.states_value.get(st) is None:
                self.states_value[st] = 0
            self.states_value[st] += self.lr * (self.decay_gamma * reward - self.states_value[st])
            reward = self.states_value[st]
</code></pre>

<h2 id="huấn-luyện-mô-hình">Huấn luyện mô hình</h2>

<p>Phần này nằm trong lớp State. Chúng ta sẽ lần lượt đi qua các quá trình luân phiên nhau giữa người chơi 1 và người chơi 2</p>

<p>người chơi chọn nước có thể đi -&gt; cập nhật trạng thái -&gt; kiểm tra thắng/thua -&gt; người chơi chọn nước có thể đi &hellip;</p>

<pre><code class="language-python">
def play(self, rounds=100):
    for i in range(rounds):
        if i % 1000 == 0:
            print(&quot;Rounds {}&quot;.format(i))
        while not self.isEnd:
            # Player 1
            positions = self.availablePositions()
            p1_action = self.p1.chooseAction(positions, self.board, self.playerSymbol)
            # take action and upate board state
            self.updateState(p1_action)
            board_hash = self.getHash()
            self.p1.addState(board_hash)
            # check board status if it is end

            win = self.winner()
            if win is not None:
                # self.showBoard()
                # ended with p1 either win or draw
                self.giveReward()
                self.p1.reset()
                self.p2.reset()
                self.reset()
                break

            else:
                # Player 2
                positions = self.availablePositions()
                p2_action = self.p2.chooseAction(positions, self.board, self.playerSymbol)
                self.updateState(p2_action)
                board_hash = self.getHash()
                self.p2.addState(board_hash)

                win = self.winner()
                if win is not None:
                    # self.showBoard()
                    # ended with p2 either win or draw
                    self.giveReward()
                    self.p1.reset()
                    self.p2.reset()
                    self.reset()
                    break

</code></pre>

<p>Sau khi huấn luyện 100 ngàn lần, chúng ta sẽ chơi với máy, chỉ là 1 thay đổi nhỏ trong hàm chooseAction là thay vì lấy nước đi có trọng số lớn nhất, chúng ta sẽ cho người dùng nhập từ bàn phím dòng và cột vào</p>

<pre><code class="language-python">

def chooseAction(self, positions):
        while True:
            row = int(input(&quot;Input your action row:&quot;))
            col = int(input(&quot;Input your action col:&quot;))
            action = (row, col)
            if action in positions:
                return action

</code></pre>

<p>Và sửa lại hàm play một chút, bỏ loop 100k lần đi, bỏ gọi hàm cập nhật thưởng và bỏ các hàm reset đi</p>

<pre><code class="language-python">

# play with human
def play2(self):
    while not self.isEnd:
        # Player 1
        positions = self.availablePositions()
        p1_action = self.p1.chooseAction(positions, self.board, self.playerSymbol)
        # take action and upate board state
        self.updateState(p1_action)
        self.showBoard()
        # check board status if it is end
        win = self.winner()
        if win is not None:
            if win == 1:
                print(self.p1.name, &quot;wins!&quot;)
            else:
                print(&quot;tie!&quot;)
            self.reset()
            break

        else:
            # Player 2
            positions = self.availablePositions()
            p2_action = self.p2.chooseAction(positions)

            self.updateState(p2_action)
            self.showBoard()
            win = self.winner()
            if win is not None:
                if win == -1:
                    print(self.p2.name, &quot;wins!&quot;)
                else:
                    print(&quot;tie!&quot;)
                self.reset()
                break

</code></pre>

<p>Mã nguồn hoàn chỉnh của chương trình</p>

<pre><code class="language-python">
import numpy as np
import pickle

BOARD_ROWS = 3
BOARD_COLS = 3


class State:
    def __init__(self, p1, p2):
        self.board = np.zeros((BOARD_ROWS, BOARD_COLS))
        self.p1 = p1
        self.p2 = p2
        self.isEnd = False
        self.boardHash = None
        # init p1 plays first
        self.playerSymbol = 1

    # get unique hash of current board state
    def getHash(self):
        self.boardHash = str(self.board.reshape(BOARD_COLS * BOARD_ROWS))
        return self.boardHash

    def winner(self):
        # row
        for i in range(BOARD_ROWS):
            if sum(self.board[i, :]) == 3:
                self.isEnd = True
                return 1
            if sum(self.board[i, :]) == -3:
                self.isEnd = True
                return -1
        # col
        for i in range(BOARD_COLS):
            if sum(self.board[:, i]) == 3:
                self.isEnd = True
                return 1
            if sum(self.board[:, i]) == -3:
                self.isEnd = True
                return -1
        # diagonal
        diag_sum1 = sum([self.board[i, i] for i in range(BOARD_COLS)])
        diag_sum2 = sum([self.board[i, BOARD_COLS - i - 1] for i in range(BOARD_COLS)])
        diag_sum = max(abs(diag_sum1), abs(diag_sum2))
        if diag_sum == 3:
            self.isEnd = True
            if diag_sum1 == 3 or diag_sum2 == 3:
                return 1
            else:
                return -1

        # tie
        # no available positions
        if len(self.availablePositions()) == 0:
            self.isEnd = True
            return 0
        # not end
        self.isEnd = False
        return None

    def availablePositions(self):
        positions = []
        for i in range(BOARD_ROWS):
            for j in range(BOARD_COLS):
                if self.board[i, j] == 0:
                    positions.append((i, j))  # need to be tuple
        return positions

    def updateState(self, position):
        self.board[position] = self.playerSymbol
        # switch to another player
        self.playerSymbol = -1 if self.playerSymbol == 1 else 1

    # only when game ends
    def giveReward(self):
        result = self.winner()
        # backpropagate reward
        if result == 1:
            self.p1.feedReward(1)
            self.p2.feedReward(0)
        elif result == -1:
            self.p1.feedReward(0)
            self.p2.feedReward(1)
        else:
            self.p1.feedReward(0.1)
            self.p2.feedReward(0.5)

    # board reset
    def reset(self):
        self.board = np.zeros((BOARD_ROWS, BOARD_COLS))
        self.boardHash = None
        self.isEnd = False
        self.playerSymbol = 1

    def play(self, rounds=100):
        for i in range(rounds):
            if i % 1000 == 0:
                print(&quot;Rounds {}&quot;.format(i))
            while not self.isEnd:
                # Player 1
                positions = self.availablePositions()
                p1_action = self.p1.chooseAction(positions, self.board, self.playerSymbol)
                # take action and upate board state
                self.updateState(p1_action)
                board_hash = self.getHash()
                self.p1.addState(board_hash)
                # check board status if it is end

                win = self.winner()
                if win is not None:
                    # self.showBoard()
                    # ended with p1 either win or draw
                    self.giveReward()
                    self.p1.reset()
                    self.p2.reset()
                    self.reset()
                    break

                else:
                    # Player 2
                    positions = self.availablePositions()
                    p2_action = self.p2.chooseAction(positions, self.board, self.playerSymbol)
                    self.updateState(p2_action)
                    board_hash = self.getHash()
                    self.p2.addState(board_hash)

                    win = self.winner()
                    if win is not None:
                        # self.showBoard()
                        # ended with p2 either win or draw
                        self.giveReward()
                        self.p1.reset()
                        self.p2.reset()
                        self.reset()
                        break
            

    # play with human
    def play2(self):
        while not self.isEnd:
            # Player 1
            positions = self.availablePositions()
            p1_action = self.p1.chooseAction(positions, self.board, self.playerSymbol)
            # take action and upate board state
            self.updateState(p1_action)
            self.showBoard()
            # check board status if it is end
            win = self.winner()
            if win is not None:
                if win == 1:
                    print(self.p1.name, &quot;wins!&quot;)
                else:
                    print(&quot;tie!&quot;)
                self.reset()
                break

            else:
                # Player 2
                positions = self.availablePositions()
                p2_action = self.p2.chooseAction(positions)

                self.updateState(p2_action)
                self.showBoard()
                win = self.winner()
                if win is not None:
                    if win == -1:
                        print(self.p2.name, &quot;wins!&quot;)
                    else:
                        print(&quot;tie!&quot;)
                    self.reset()
                    break
        

    def showBoard(self):
        # p1: x  p2: o
        for i in range(0, BOARD_ROWS):
            print('-------------')
            out = '| '
            for j in range(0, BOARD_COLS):
                token = &quot;&quot;
                if self.board[i, j] == 1:
                    token = 'x'
                if self.board[i, j] == -1:
                    token = 'o'
                if self.board[i, j] == 0:
                    token = ' '
                out += token + ' | '
            print(out)
        print('-------------')


class Player:
    def __init__(self, name, exp_rate=0.3):
        self.name = name
        self.states = []  # record all positions taken
        self.lr = 0.3
        self.exp_rate = exp_rate
        self.decay_gamma = 0.9
        self.states_value = {}  # state -&gt; value

    def getHash(self, board):
        boardHash = str(board.reshape(BOARD_COLS * BOARD_ROWS))
        return boardHash

    def chooseAction(self, positions, current_board, symbol):
        randValue = np.random.uniform(0, 1)
        value_max = value = -999
        if  randValue&gt; self.exp_rate:
            
            for p in positions:
                next_board = current_board.copy()
                next_board[p] = symbol
                next_boardHash = self.getHash(next_board)
                value = -999 if self.states_value.get(next_boardHash) is None else self.states_value.get(next_boardHash)
                # print(&quot;value&quot;, value)
                if value &gt;= value_max:
                    value_max = value
                    action = p

        if  value_max == -999 :
            # take random action
            idx = np.random.choice(len(positions))
            action = positions[idx]
        
        # print(&quot;{} takes action {}&quot;.format(self.name, action))
        return action

    # append a hash state
    def addState(self, state):
        self.states.append(state)

    # at the end of game, backpropagate and update states value
    def feedReward(self, reward):
        for st in reversed(self.states):
            if self.states_value.get(st) is None:
                self.states_value[st] = 0
            self.states_value[st] += self.lr * (self.decay_gamma * reward - self.states_value[st])
            reward = self.states_value[st]

    def reset(self):
        self.states = []

    def savePolicy(self):
        fw = open('policy_' + str(self.name), 'wb')
        pickle.dump(self.states_value, fw)
        fw.close()

    def loadPolicy(self, file):
        fr = open(file, 'rb')
        self.states_value = pickle.load(fr)
        fr.close()


class HumanPlayer:
    def __init__(self, name):
        self.name = name

    def chooseAction(self, positions):
        while True:
            row = int(input(&quot;Input your action row:&quot;))
            col = int(input(&quot;Input your action col:&quot;))
            action = (row, col)
            if action in positions:
                return action

    # append a hash state
    def addState(self, state):
        pass

    # at the end of game, backpropagate and update states value
    def feedReward(self, reward):
        pass

    def reset(self):
        pass


if __name__ == &quot;__main__&quot;:
    # training
    p1 = Player(&quot;p1&quot;)
    p2 = Player(&quot;p2&quot;)

    st = State(p1, p2)
    print(&quot;training...&quot;)
    st.play(100000)

    p1.savePolicy()

    # play with human
    p1 = Player(&quot;computer&quot;, exp_rate=0)
    p1.loadPolicy(&quot;policy_p1&quot;)

    p2 = HumanPlayer(&quot;human&quot;)

    st = State(p1, p2)
    st.play2()



</code></pre>

<p>Nguồn</p>

<ul>
<li><p>Reinforcement Learning: An Introduction phiên bản 2 của Richard S. Sutton and Andrew G. Barto</p></li>

<li><p><a href="https://towardsdatascience.com/reinforcement-learning-implement-tictactoe-189582bea542">https://towardsdatascience.com/reinforcement-learning-implement-tictactoe-189582bea542</a></p></li>
</ul>

	<div style="    margin: 0;
    border-bottom: 1px dotted #d9d9d9;
    padding-bottom: 20px;"></div>
	<div><i class='fas fa-donate'>Nếu bạn thấy nội dung của bài viết thật sự hữu ích và bạn muốn đóng góp cho blog để có thêm nhiều bài viết chất lượng hơn nữa, các bạn có thể ủng hộ blog bằng một cốc trà hoặc một cốc cà phê nhỏ qua <a target="_blank" href="https://nhantien.momo.vn/7abl2tSivGa"> https://nhantien.momo.vn/7abl2tSivGa</a> hoặc <a  target="_blank" href="paypal.me/tungduypham">paypal.me/tungduypham</a>. Sự ủng hộ của các bạn là nguồn động viên quý giá để chúng tôi có thêm động lực và chia sẻ nhiều điều mà chúng tôi tìm hiểu được đến với cộng đồng. Trân trọng cảm ơn.</i></div>
  </div>
  
		
  <footer class="col-md-10  mx-auto">
  <ul class="stats list-unstyled">
 
    
  <li class="tags">
    <ul class="list-inline">
       
            
            
                <i class="fa fa-tags"></i>
                
                
                <li class="list-inline-item"><a class="article-category-link" href="/tags/python">python</a></li>
                
                
                <li class="list-inline-item"><a class="article-category-link" href="/tags/tetris">tetris</a></li>
                
                
                <li class="list-inline-item"><a class="article-category-link" href="/tags/opencv">opencv</a></li>
                
            
        
    </ul>
  </li>
  
</ul>

  <div class="fb-like" data-share="true"  data-width="800"  data-show-faces="true">
</div>
    
  </footer>
  <hr/>
<div class="infinite-container featured-task col-md-8 mx-auto">
<div class="titlerelate">Bài viết khác</div>

<div class="card-deck card-break infinite-item">



    
        <div class="card  col-md-6" style="padding-top:15px;">
		<a href="/blog/2020-12-25---tetric/"
                class="button big previous">
		
		<img class="card-img-top lazy" src="/thumbnails/chum_vigro.jpg" width="100" />
		<div class="card-body">
		<h5 class="card-title">
		Xây dựng game xếp gạch bằng opencv và python
				</h5>
				</div>
				</a>
				</div>
    

    
        <div class="card  col-md-6"  style="padding-top:15px;">
		<a href="/blog/2021-01-15---adabelief-optimizer/"
                class="button big previous">
		
		<img class="card-img-top lazy" src="/thumbnails/adam_lstm.jpg" width="100" />
		
		<div class="card-body">
		<h5 class="card-title">
		Tìm hiểu thuật toán tối ưu hóa Adabelief Optimizer
				</h5>
				</div>
				</a>
				</div>
    

</div>
</div>



<div class="fb-comments" data-href="" data-width="" data-numposts="5"></div>

    <article class="post">
        
        <div class="disqus-comments">                  
            <button id="show-comments" class="btn btn-warning" type="button">Show <span class="disqus-comment-count" data-disqus-url="blog/2020-12-26---tic-tac-toe">comments</span></button>
            <div id="disqus_thread"></div>
          </div>
    </article>





		
    </main>
    
<section id="sidebar" class="col-md-3">
<br/>
<div>
		<ul class="list-group" id="news-contents"></ul>
    <div id="calander">
	</div>
    </div>

  
   
  
  
  
  
  
  
  
  
 

</section>

</div>
	</div>
    
	<hr>
  <footer class="footer">
  <div class="container text-center">
    
    <p class="copyright">
      
        &copy; 2018 Phạm Duy Tùng. Website chia sẻ kiến thức của Phạm Duy Tùng và Đặng Thị Hằng. Vui lòng liên hệ email alexblack2202@gmail.com nếu bạn có thông tin cần trao đổi.
      
     
    </p>
	
	<a href="//www.dmca.com/Protection/Status.aspx?ID=5cadb1e5-83a1-4033-96e9-b0f21edfaca7" title="DMCA.com Protection Status" class="dmca-badge"> <img src ="https://images.dmca.com/Badges/dmca_protected_sml_120m.png?ID=5cadb1e5-83a1-4033-96e9-b0f21edfaca7"  alt="DMCA.com Protection Status" /></a>  <script src="https://images.dmca.com/Badges/DMCABadgeHelper.min.js"> </script>
	</div>
	

      <div id="fb-root"></div>
      <script>
        window.fbAsyncInit = function() {
          FB.init({
            xfbml            : true,
            version          : 'v10.0'
          });
        };

        (function(d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) return;
        js = d.createElement(s); js.id = id;
        js.src = 'https://connect.facebook.net/vi_VN/sdk/xfbml.customerchat.js';
        fjs.parentNode.insertBefore(js, fjs);
      }(document, 'script', 'facebook-jssdk'));</script>

      
      <div class="fb-customerchat"
        attribution="setup_tool"
        page_id="1244186728962161">
      </div>
  </footer>
    
    

    
      
    

    
      
      
      
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
        
        
        
        <script  src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/languages/python.min.js"></script>
        <script defer="defer" async="async">hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>
      
    
    
    
    <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/skel/3.0.1/skel.min.js"></script>
     

   <script  src="/js/jquery-2.2.4.min.js" data-cfasync="false"></script>
   
    <script defer="defer" async="async" src="/js/bootstrap.min.js"></script>
      <script defer="defer" async="async" src="/js/util.js"></script>
	  
      <script defer="defer"  src="/js/main.js"></script>
     
    

    
      
        
      
    
	
    
    
      

<script defer="defer" async="async" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script  defer="defer" async="async" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


	  
	  
	   

<script id="dsq-count-scr" src="//phamduytung.disqus.com/count.js" async></script>

 <script defer="defer"   src="/js/jquery.amlich.js" data-cfasync="false" ></script>
	   <script defer="defer"   type="text/javascript"  data-cfasync="false">

  function getcontent(){
 

   

           
                }
            
			
			$(document).ready(function(){
      getcontent();
      $('#calander').amLich({
  type: 'calendar', 
  tableWidth: '100%' 
});
  

			}); 
			
			
			$(function(){
  $('#show-comments').on('click', function(){
    var disqus_shortname = 'phamduytung';

    (function() {
      var disqus = document.createElement('script'); 
      disqus.type = 'text/javascript'; 
      disqus.async = true;
      disqus.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(disqus);
    })();

    $(this).hide(); 
  });
});

var disqus_config = function () {
  this.page.url = 'blog\/2020-12-26---tic-tac-toe';
};
</script>


 


  </body>
</html>

