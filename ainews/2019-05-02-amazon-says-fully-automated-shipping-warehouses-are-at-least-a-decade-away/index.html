


    




<!DOCTYPE HTML>

<html>
    <head>
        <script type="application/ld+json">
    {
        "@context" : "http://schema.org",
        "@type" : "BlogPosting",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "/"
        },
        "articleSection" : "ainews",
        "name" : "Amazon cần một thập kỷ nữa để hoàn thành kho hàng tự động",
        "headline" : "Amazon cần một thập kỷ nữa để hoàn thành kho hàng tự động",
        "description" : "Machine Learning đã và đang được quan tâm, nghiên cứu sâu rộng, có rất nhiều các thuật toán được cho ra đời. Như vậy liệu các thuật toán ấy có đặc điểm hay chức năng tương đồng và có cách nào để dễ nhớ hay không. Trong bài viết này mình sẽ chia sẻ với các bạn các cách để phân nhóm các thuật toán ML.",
        "inLanguage" : "en",
        "author" : "",
        "creator" : "",
        "publisher": "",
        "accountablePerson" : "",
        "copyrightHolder" : "",
        "copyrightYear" : "2019",
        "datePublished": "2019-04-19 00:12:00 &#43;0300 &#43;0300",
        "dateModified" : "2019-04-19 00:12:00 &#43;0300 &#43;0300",
        "url" : "/ainews/2019-05-02-amazon-says-fully-automated-shipping-warehouses-are-at-least-a-decade-away/",
        "wordCount" : "4467",
        "keywords" : [ "machine learning","deep learning","học có giám sát","học không giám sát","học tăng cường","Blog" ]
    }
    </script>
        
            <title>Amazon cần một thập kỷ nữa để hoàn thành kho hàng tự động - Phạm Duy Tùng Machine Learning Blog</title>
        

        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        
		<meta name="generator" content="Phạm Duy Tùng" />
        
  
    
  

  

  
  
  
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content='/favicon/mstile.png'>
  <meta name="application-name" content="Phạm Duy Tùng Machine Learning Blog">
  <meta name="msapplication-tooltip" content="Blog ML của Phạm Duy Tùng và Đặng Thị Hằng">
   
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">



        
            <meta name="author" content="Đặng Thị Hằng">
        
        
            <meta name="description" content="Machine Learning đã và đang được quan tâm, nghiên cứu sâu rộng, có rất nhiều các thuật toán được cho ra đời. Như vậy liệu các thuật toán ấy có đặc điểm hay chức năng tương đồng và có cách nào để dễ nhớ hay không. Trong bài viết này mình sẽ chia sẻ với các bạn các cách để phân nhóm các thuật toán ML.">
        

        <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Amazon cần một thập kỷ nữa để hoàn thành kho hàng tự động"/>
<meta name="twitter:description" content="Machine Learning đã và đang được quan tâm, nghiên cứu sâu rộng, có rất nhiều các thuật toán được cho ra đời. Như vậy liệu các thuật toán ấy có đặc điểm hay chức năng tương đồng và có cách nào để dễ nhớ hay không. Trong bài viết này mình sẽ chia sẻ với các bạn các cách để phân nhóm các thuật toán ML."/>
<meta name="twitter:site" content="@example"/>

        <meta property="og:title" content="Amazon cần một thập kỷ nữa để hoàn thành kho hàng tự động" />
<meta property="og:description" content="Machine Learning đã và đang được quan tâm, nghiên cứu sâu rộng, có rất nhiều các thuật toán được cho ra đời. Như vậy liệu các thuật toán ấy có đặc điểm hay chức năng tương đồng và có cách nào để dễ nhớ hay không. Trong bài viết này mình sẽ chia sẻ với các bạn các cách để phân nhóm các thuật toán ML." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/ainews/2019-05-02-amazon-says-fully-automated-shipping-warehouses-are-at-least-a-decade-away/" /><meta property="article:published_time" content="2019-04-19T00:12:00&#43;03:00"/>
<meta property="article:modified_time" content="2019-04-19T00:12:00&#43;03:00"/>

        <meta property="og:image" content="//images/logo.png">
        <meta property="og:image:type" content="image/png">
        <meta property="og:image:width" content="512">
        <meta property="og:image:height" content="512">
        
<meta itemprop="name" content="Amazon cần một thập kỷ nữa để hoàn thành kho hàng tự động">
<meta itemprop="description" content="Machine Learning đã và đang được quan tâm, nghiên cứu sâu rộng, có rất nhiều các thuật toán được cho ra đời. Như vậy liệu các thuật toán ấy có đặc điểm hay chức năng tương đồng và có cách nào để dễ nhớ hay không. Trong bài viết này mình sẽ chia sẻ với các bạn các cách để phân nhóm các thuật toán ML.">


<meta itemprop="datePublished" content="2019-04-19T00:12:00&#43;03:00" />
<meta itemprop="dateModified" content="2019-04-19T00:12:00&#43;03:00" />
<meta itemprop="wordCount" content="4467">



<meta itemprop="keywords" content="machine learning,deep learning,học có giám sát,học không giám sát,học tăng cường," />

        

        
            
        

        
        
          
			
			 <link rel="stylesheet" href="/css/font-awesome.min.css">
			 <link rel="stylesheet" href="/css/bootstrap.min.css">


          
            <link rel="stylesheet" href="/css/academicons.min.css">
        

        
            
                
            
        


  
    
    <link href='//cdn.bootcss.com/highlight.js/9.15.8/styles/xcode.min.css' rel='stylesheet' type='text/css' />
  


      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-114911596-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

	  
	  <style>
	  
	  body{
font-family: Helvetica,Arial,sans-serif;
}

.card{
	margin-bottom: 10px;
}

#disqus_thread{
padding: 0 5px;
}

.item-header{
padding: 0;
}

.single-content-img{
width: 100%;
    max-height: 450px !important;
    background-size: cover;
    display: block;
    background-position: center;
}

.thumbnail {
    position: relative;
}

.caption {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
	background: rgba(0, 0, 0, 0.25);
	text-align:left;
}

.caption .title{
	font-size: 1.6em;
    line-height: 1.4em;
    top: 0;
	margin-left:20px;
	margin-top:20px;
	
}

.caption .title-caption{
margin-left:10px;
}

#content p{
text-align: justify;
    line-height: 1.9;
    font-size: 12pt;
}

#content img{
	display: block;
    margin-left: auto;
margin-right: auto;
max-width:98%;
}

img + strong {
    font-style: normal;
    display: inherit;
    text-align: center;
}
.img-news{
max-height:150px;
width:100%;
}

.news-tittle{
	padding-top:15px;
	text-align:justify;
}

.author{
	color: orange;
}
.author-inline{
	color: orange;
}

.adv{
height:18px;
}


.hljs{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;}
.titledetail {
    display: block;
    overflow: hidden;
    line-height: 53px;
    font-size: 45px;
    font-family: 'Roboto Condensed',sans-serif;
    font-weight: 600;
    width: 800px;
    margin: auto;
	padding: 0 ;
}

.newsrelate {
    display: block;
    overflow: hidden;
	 list-style:none;
}
a ,a:hover{
    text-decoration: none;
}
.newsrelate li {
    float: left;
    overflow: hidden;
    width: 30%;
    margin-left: 2.5%;
    margin-bottom: 15px;
}

.newsrelate li a {
    display: block;
    overflow: hidden;
}

.userdetail {
    display: block;
    overflow: hidden;
    margin: 0 10px 0 0;
    padding: 15px 0;
}
.newsrelate li h3 {
    display: block;
    overflow: hidden;
    line-height: 1.3em;
    font-size: 16pt;
    line-height: 22px;
    font-weight: 300;
    font-family: Arial,Helvetica,sans-serif;
    width: auto;
    margin: 5px auto;
}

.titlerelate {
    overflow: hidden;
    font-size: 18px;
    font-weight: 600;
    font-family: 'Roboto Condensed',sans-serif;
    line-height: 32px;
    text-transform: uppercase;
}
article .captionnews {
    color: #999;
    font-size: 14px;
    font-style: italic;
    padding: 10px;
    text-align: center;
    margin-bottom: 15px;
}

	  </style>

    </head>
    <body>
<script>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '1546237302193677',
      xfbml      : true,
      version    : 'v5.0'
    });
    FB.AppEvents.logPageView();
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "https://connect.facebook.net/en_US/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>
<div id="fb-root"></div>
<script async defer crossorigin="anonymous" src="https://connect.facebook.net/vi_VN/sdk.js#xfbml=1&version=v5.0&appId=1853483258232756&autoLogAppEvents=1"></script>
      
      

    
<header id="header"  style="background: #790014; color: hsla(0,0%,100%,1);">
<div class="container">
    <nav class="navbar navbar-expand-md navbar-dark">
	
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav mr-auto">
            
                <li class="nav-item">
                    <a class='nav-link' href="/blog">
                            <i class="fa fa-home active">&nbsp;</i>Home
                    </a>
                </li>
            
                <li class="nav-item">
                    <a class='nav-link' href="/news/">
                            <i class="fa fa-list">&nbsp;</i>News
                    </a>
                </li>
            
                <li class="nav-item">
                    <a class='nav-link' href="/xem-truyen/">
                            <i class="fa fa-id-card-o">&nbsp;</i>Truyện
                    </a>
                </li>
            
        </ul>
    </nav>
    </div></div>
</header>


    
    <div class="container">
        <article class="post">
            
            <header>
    <div class="title">
        
            <h1><a href="/ainews/2019-05-02-amazon-says-fully-automated-shipping-warehouses-are-at-least-a-decade-away/">Amazon cần một thập kỷ nữa để hoàn thành kho hàng tự động</a></h1>
            
        
        
            <p>Machine Learning đã và đang được quan tâm, nghiên cứu sâu rộng, có rất nhiều các thuật toán được cho ra đời. Như vậy liệu các thuật toán ấy có đặc điểm hay chức năng tương đồng và có cách nào để dễ nhớ hay không. Trong bài viết này mình sẽ chia sẻ với các bạn các cách để phân nhóm các thuật toán ML.</p>
        
    </div>
</header>

            <div id="content" class="col-md-8 mx-auto">
                

<p>Ở bài trước mình đã trình bày định nghĩa và một số ứng dụng của Máy học (Machine Learning – ML), phân biệt ML với Trí tuệ nhân tạo (Artificial Intelligence – AI) cũng như mối quan hệ giữa AI, ML và Big Data. Từ bài viết này trở đi mình sẽ tập trung viết về ML, các thuật toán, cách sử dụng công cụ kèm theo một vài demo nhỏ giúp bạn đọc dễ hình dung và áp dụng. Để mở đầu cho chuỗi bài viết sắp tới, hôm nay mình sẽ trình bày cách phân nhóm các thuật toán ML.</p>

<p>Với đa số mọi người, trước khi bắt đầu giải quyết một vấn đề nào đó, việc đầu tiên là chúng ta sẽ tìm hiểu xem liệu có ai đã gặp vấn đề này hoặc vấn đề tương tự như vậy hay không và cách họ giải quyết thế nào. Sau khi nắm được thông tin khái quát, công việc kế tiếp là chọn lựa và điều chỉnh giải pháp sao cho phù hợp với vấn đề của bản thân. Trong trường hợp vấn đề còn quá mới mẻ thì chúng ta mới phải bắt tay làm từ đầu, điều này hầu như rất hiếm, đặc biệt là trong thời đại công nghệ này, khi mà chỉ bằng một cú nhấp chuột, hàng ngàn thông tin, tư liệu về đề tài chúng ta quan tâm sẽ xuất hiện. Cũng giống như thế, ML hiện đã được nghiên cứu rộng khắp, rất nhiều công trình khoa học, thuật toán được cho ra đời. Với người mới bắt đầu mà nói thì chúng ta chưa cần phải làm gì cả ngoài việc nắm được các thuật toán cơ bản, đặc điểm của chúng để khi đối diện với một bài toán cụ thể trong thực tế chúng ta có thể biết được mình nên lựa chọn thuật toán nào cho phù hợp đã là điều rất tốt rồi.</p>

<p>Mặc dù có rất nhiều thuật toán học nhưng dựa vào phương thức học (learning style) hoặc sự tương đồng (similarity) về hình thức hay chức năng mà chúng có thể được gom thành từng nhóm. Sau đây mình sẽ trình bày tổng quan cả hai cách phân nhóm thuật toán học này.</p>

<h1 id="1-phân-nhóm-dựa-trên-phương-thức-học">1.    Phân nhóm dựa trên phương thức học</h1>

<p>Xét theo phương thức học, các thuật toán ML được chia làm bốn nhóm, bao gồm “Học có giám sát” (Supervised Learning), “Học không giám sát” (Unsupervised Learning), “Học bán giám sát” (hay học kết hợp - Semi-supervised Learning) và “Học tăng cường” (Reinforcement Learning).</p>

<h2 id="a-học-có-giám-sát">a.   Học có giám sát</h2>

<p>Học có giám sát hay còn gọi là học có thầy là thuật toán dự đoán nhãn (label)/đầu ra (output) của một dữ liệu mới dựa trên tập dữ liệu huấn luyện mà trong đó mỗi mẫu dữ liệu đều đã được gán nhãn như minh hoạ ở Hình 1. Khi đó, thông qua một quá trình huấn luyện, một mô hình sẽ được xây dựng để cho ra các dự đoán và khi các dự đoán bị sai thì mô hình này sẽ được tinh chỉnh lại. Việc huấn luyện sẽ tiếp tục cho đến khi mô hình đạt được mức độ chính xác mong muốn trên dữ liệu huấn luyện. Điều này cũng giống như khi chúng ta đi học trên lớp, ta biết câu trả lời chính xác từ giáo viên (tập dữ liệu có nhãn) và từ đó ta sẽ sửa chữa nếu làm sai. Học có giám sát là nhóm phổ biến nhất trong các thuật toán ML.</p>

<p><img src="/post_image/supervised-learning.jpg" alt="Hình ảnh" />
<strong>Hình 1: Supervised Learning Algorithms</strong></p>

<p>Một cách toán học, học có giám sát là khi chúng ra có một tập hợp biến đầu vào <code>$ X={x_1,x_2,…,x_N} $</code> và một tập hợp nhãn tương ứng <code>$ Y={y_1,y_2,…,y_N} $</code>, trong đó <code>$ x_i$</code>, <code>$y_i $</code> là các vector. Các cặp dữ liệu biết trước <code>$( x_i, y_i ) \in X \times Y $</code> được gọi là tập dữ liệu huấn luyện (training data). Từ tập dữ liệu huấn luyện này, chúng ta cần tạo ra một hàm số ánh xạ mỗi phần tử từ tập X sang một phần tử (xấp xỉ) tương ứng của tập Y:</p>

<p>$$ y_i \approx f(x_i), \forall i=1, 2, …, N $$</p>

<p>Mục đích là xấp xỉ hàm số <code>$f$</code> thật tốt để khi có một dữ liệu x mới, chúng ta có thể tính được nhãn tương ứng của nó <code>$y=f(x)$</code>.</p>

<p>Ví dụ: Trong nhận dạng chữ số viết tay, ta có ảnh của hàng nghìn trường hợp ứng với mỗi chữ số được viết bởi nhiều người khác nhau. Ta đưa các bức ảnh này vào một thuật toán học và chỉ cho nó biết “mỗi bức ảnh tương ứng với chữ số nào”. Sau khi thuật toán tạo ra một mô hình, tức là một hàm số nhận đầu vào là một bức ảnh và cho ra kết quả là một chữ số. Khi nhận được một bức ảnh mới mà mô hình “chưa từng gặp qua” và nó sẽ dự đoán xem bức ảnh đó tương ứng với chữ số nào.</p>

<p><img src="/post_image/mnist-900x506.png" alt="Hình ảnh" />
<strong>Hình 2: Ảnh minh hoạ cho tập dữ liệu chữ số viết tay - MNIST</strong></p>

<p>Đối với những ai sử dụng mạng xã hội Facebook thì khá quen thuộc với tính năng phát hiện khuôn mặt trong một bức ảnh, bản chất của thuật toán dò tìm các khuôn mặt này là một thuật toán học có giám sát với tập huấn luyện là vô số ảnh đã được gán nhãn là mặt người hay không phải mặt người.</p>

<p>Các thuật toán học có giám sát còn được phân ra thành hai loại chính là phân lớp (Classification) và hồi quy (Regression).</p>

<h3 id="phân-lớp">Phân lớp</h3>

<p>Một bài toán được gọi là phân lớp nếu các nhãn của dữ liệu đầu vào được chia thành một số hữu hạn lớp (miền giá trị là rời rạc). Chẳng hạn như tính năng xác định xem một email có phải là spam hay không của Gmail; xác định xem hình ảnh của con vật là chó hay mèo. Hoặc ví dụ nhận dạng ký số viết tay ở trên cũng thuộc bài toán phân lớp, bao gồm mười lớp ứng với các số từ 0 đến 9. Tương tự cho ví dụ nhận dạng khuôn mặt với hai lớp là phải và không phải khuôn mặt, …</p>

<h3 id="hồi-quy">Hồi quy</h3>

<p>Một bài toán được xem là hồi quy nếu nhãn không được chia thành các nhóm mà là một giá trị thực cụ thể (miền giá trị là liên tục). Hầu hết các bài toán dự báo (giá cổ phiếu, giá nhà, …) thường được xếp vào bài toán hồi quy. Ví như, nếu một căn nhà rộng 150 m^2, có 7 phòng và cách trung tâm thành phố 10 km sẽ có giá là bao nhiêu? Lúc này kết quả dự đoán sẽ là một số thực.</p>

<p>Nếu như phát hiện khuôn mặt là bài toán phân lớp thì dự đoán tuổi là bài toán hồi quy. Tuy nhiên dự đoán tuổi cũng có thể coi là phân lớp nếu ta cho tuổi là một số nguyên dương N và khi đó ta sẽ có N lớp khác nhau tính từ 1.
Một số thuật toán nổi tiếng thuộc về nhóm học có giám sát như:</p>

<ul>
<li><p>Phân lớp: k-Nearest Neighbors, mạng nơron nhân tạo, SVM, …</p></li>

<li><p>Hồi quy: Linear Regression, Logistic Regression, …</p></li>
</ul>

<h2 id="b-học-không-giám-sát">b. Học không giám sát</h2>

<p>Trái với Supervised learning, học không giám sát hay học không thầy là thuật toán dự đoán nhãn của một dữ liệu mới dựa trên tập dữ liệu huấn luyện mà trong đó tất cả các mẫu dữ liệu đều chưa được gán nhãn hay nói cách khác là ta không biết câu trả lời chính xác cho mỗi dữ liệu đầu vào như minh hoạ ở Hình 3. Điều này cũng giống như khi ta học mà không có thầy cô, sẽ không ai cho ta biết đáp án đúng là gì.</p>

<p><img src="/post_image/unsupervisedlearning.jpg" alt="Hình ảnh" />
<strong>Hình 3: Unsupervised Learning Algorithms</strong></p>

<p>Khi đó, mục tiêu của thuật toán unsupervised learning không phải là tìm đầu ra chính xác mà sẽ hướng tới việc tìm ra cấu trúc hoặc sự liên hệ trong dữ liệu để thực hiện một công việc nào đó, ví như gom cụm (clustering) hoặc giảm số chiều của dữ liệu (dimension reduction) để thuận tiện trong việc lưu trữ và tính toán.</p>

<p>Các bài toán Unsupervised learning tiếp tục được chia nhỏ thành hai loại là phân cụm (Clustering) và luật kết hợp (Association Rule).</p>

<h3 id="phân-cụm">Phân cụm</h3>

<p>Một bài toán phân cụm / phân nhóm toàn bộ dữ liệu X thành các nhóm/cụm nhỏ dựa trên sự liên quan giữa các dữ liệu trong mỗi nhóm. Chẳng hạn như phân nhóm khách hàng dựa vào độ tuổi, giới tính. Điều này cũng giống như việc ta đưa cho một đứa trẻ rất nhiều mảnh ghép với các hình dạng và màu sắc khác nhau, có thể là tam giác, vuông, tròn với màu xanh, đỏ, tím, vàng, sau đó yêu cầu trẻ phân chúng thành từng nhóm. Mặc dù ta không dạy trẻ mảnh nào tương ứng với hình nào hoặc màu nào, nhưng nhiều khả năng trẻ vẫn có thể phân loại các mảnh ghép theo màu sắc hoặc hình dạng.</p>

<h3 id="luật-kết-hợp">Luật kết hợp</h3>

<p>Là bài toán mà khi chúng ta muốn khám phá ra một quy luật dựa trên nhiều dữ liệu cho trước. Ví như những khách hàng mua mặt hàng này sẽ mua thêm mặt hàng kia; hoặc khan giả xem phim này sẽ có xu hướng thích xem phim kia, dựa vào đó ta có thể xây dựng những hệ thống gợi ý khách hàng (Recommendation System) nhằm thúc đẩy nhu cầu mua sắm hoặc xem phim&hellip;.</p>

<p>Một số thuật toán thuộc nhóm học không giám sát như Apriori (Association Rule), k-Means (Clustering), …</p>

<h2 id="c-học-bán-giám-sát">c.   Học bán giám sát</h2>

<p>Là bài toán mà khi tập dữ liệu đầu vào X là hỗn hợp các mẫu có nhãn và không có nhãn, trong đó số lượng có nhãn chỉ chiếm một phần nhỏ như minh hoạ ở Hình 4.</p>

<p>Phần lớn các bài toán thực tế của ML thuộc nhóm này vì việc thu thập dữ liệu có nhãn tốn rất nhiều thời gian và có chi phí cao. Rất nhiều loại dữ liệu thậm chí cần phải có chuyên gia mới gán nhãn được, chẳng hạn như ảnh y học hoặc các cặp câu song ngữ. Ngược lại, dữ liệu chưa có nhãn có thể được thu thập với chi phí thấp từ internet.</p>

<p><img src="/post_image/semi-supervisedlearning.jpg" alt="Hình ảnh" />
<strong>Hình 4: Semi-supervised Learning Algorithms</strong></p>

<p>Với bài toán này, mô hình phải tìm hiểu các cấu trúc để tổ chức dữ liệu cũng như đưa ra dự đoán. Vì đặc điểm trung gian nên ta có thể sử dụng unsupervised learning để khám phá và tìm hiểu cấu trúc trong dữ liệu đầu vào, đồng thời sử dụng supervised learning để dự đoán cho dữ liệu không được gán nhãn. Sau đó đưa dữ liệu vừa dự đoán trở lại làm dữ liệu huấn luyện cho supervised learning và sử dụng mô hình sau khi huấn luyện để đưa ra dự đoán về dữ liệu mới.</p>

<p>Một số thuật toán học tăng cường như: Self Training, Generative models, S3VMs, Graph-Based Algorithms, Multiview Algorithms, …</p>

<h2 id="d-học-tăng-cường">d.   Học tăng cường</h2>

<p>Học tăng tường hay học củng cố là bài toán giúp cho một hệ thống tự động xác định hành vi dựa trên hoàn cảnh để đạt được lợi ích cao nhất. Hiện tại, reinforcement learning chủ yếu được áp dụng vào Lý Thuyết Trò Chơi (Game Theory), các thuật toán cần xác định nước đi tiếp theo để đạt được điểm số cao nhất. Hình 5 là một ví dụ đơn giản sử dụng học tăng cường.</p>

<p><img src="/post_image/reinforcementlearning.jpg" alt="Hình ảnh" />
<strong>Hình 5: Minh hoạ cho học tăng cường được áp dụng trong lý thuyết trò chơi.</strong></p>

<p>AlphaGo - một phần mềm chơi cờ vây trên máy tính được xây dựng bởi Google DeepMind hay chương trình dạy máy tính chơi game Mario là những ứng dụng sử dụng học tăng cường.</p>

<p>Cờ vậy được xem là trò chơi có độ phức tạp cực kỳ cao với tổng số nước đi là xấp xỉ 1076110761, so với cờ vua là 1012010120, vì vậy thuật toán phải chọn ra một nước đi tối ưu trong số hàng tỉ tỉ lựa chọn. Về cơ bản, AlphaGo bao gồm các thuật toán thuộc cả Supervised learning và Reinforcement learning. Trong phần Supervised learning, dữ liệu từ các ván cờ do con người chơi với nhau được đưa vào để huấn luyện. Tuy nhiên, mục tiêu cuối cùng của AlphaGo không phải là chơi như con người mà phải thắng được con người. Vì vậy, sau khi học xong các ván cờ của con người, AlphaGo tự chơi với chính nó thông qua hàng triệu ván cờ để tìm ra các nước đi mới tối ưu hơn. Thuật toán trong phần tự chơi này được xếp vào loại Reinforcement learning.</p>

<p>Đơn giản hơn cờ vây, tại một thời điểm cụ thể, người chơi game Mario chỉ cần bấm một số lượng nhỏ các nút (di chuyển, nhảy, bắn đạn) hoặc không cần bấm nút nào ứng với một chướng ngại vật cố định ở một vị trí cố định. Khi đó thuật toán trong ứng dụng dạy máy tính chơi game Mario sẽ nhận đầu vào là sơ đồ của màn hình tại thời điểm hiện hành, nhiệm vụ của thuật toán là tìm ra tổ hợp phím nên được bấm ứng với đầu vào đó. Việc huấn luyện này được dựa trên điểm số cho việc di chuyển được bao xa với thời gian bao lâu trong game, càng xa và càng nhanh thì điểm thưởng đạt được càng cao, tất nhiên điểm thưởng này không phải là điểm của trò chơi mà là điểm do chính người lập trình tạo ra. Thông qua huấn luyện, thuật toán sẽ tìm ra một cách tối ưu để tối đa số điểm trên, qua đó đạt được mục đích cuối cùng là cứu công chúa.</p>

<p>Có nhiều cách khác nhau để thuật toán có thể mô hình hóa một vấn đề dựa trên sự tương tác của nó với dữ liệu đầu vào. Phân loại hoặc cách tổ chức thuật toán học máy này rất hữu ích vì nó buộc chúng ta phải suy nghĩ về vai trò của dữ liệu đầu vào và quy trình chuẩn bị mô hình và chọn một thuật toán phù hợp nhất cho vấn đề của chúng ta để có kết quả tốt nhất.</p>

<h1 id="2-phân-nhóm-dựa-trên-sự-tương-đồng">2.    Phân nhóm dựa trên sự tương đồng</h1>

<p>Dựa vào sự tương đồng về chức năng hay cách thức hoạt động mà các thuật toán sẽ được gom nhóm với nhau. Sau đây là danh sách các nhóm và các thuật toán theo từng nhóm.</p>

<h2 id="a-các-thuật-toán-hồi-quy-regression-algorithms">a.   Các thuật toán hồi quy (Regression Algorithms)</h2>

<p>Hồi quy là quá trình tìm mối quan hệ phụ thuộc của một biến (được gọi là biến phụ thuộc hay biến được giải thích, biến được dự báo, biến được hồi quy, biến phản ứng, biến nội sinh) vào một hoặc nhiều biến khác (được gọi là biến độc lập, biến giải thích, biến dự báo, biến hồi quy, biến tác nhân hay biến kiểm soát, biến ngoại sinh) nhằm mục đích ước lượng hoặc tiên đoán giá trị kỳ vọng của biến phụ thuộc khi biết trước giá trị của biến độc lập. Hình 6 tượng trưng cho ý tưởng của các thuật toán hồi quy.</p>

<p>Ví dụ như, dự đoán rằng nếu tăng lãi suất tiền gửi thì sẽ huy động được lượng tiền gửi nhiều hơn, khi đó ngân hàng A cần biết mối quan hệ giữa lượng tiền gửi và lãi suất tiền gửi, cụ thể hơn họ muốn biết khi tăng lãi suất thêm 0.1% thì lượng tiền gửi sẽ tăng trung bình là bao nhiêu.</p>

<p>Các thuật toán hồi quy phổ biến nhất là:</p>

<ul>
<li><p>Linear Regression</p></li>

<li><p>Logistic Regression</p></li>

<li><p>Locally Estimated Scatterplot Smoothing (LOESS)</p></li>

<li><p>Multivariate Adaptive Regression Splines (MARS)</p></li>

<li><p>Ordinary Least Squares Regression (OLSR)</p></li>

<li><p>Stepwise Regression</p></li>
</ul>

<p><img src="/post_image/regression-algorithn.jpg" alt="Hình ảnh" />
<strong>Hình 6: Regression Algorithms</strong></p>

<h2 id="b-thuật-toán-dựa-trên-mẫu-instance-based-algorithms">b.   Thuật toán dựa trên mẫu (Instance-based Algorithms)</h2>

<p>Mô hình học tập dựa trên mẫu hay thực thể là bài toán ra quyết định dựa vào các trường hợp hoặc các mẫu dữ liệu huấn luyện được coi là quan trọng hay bắt buộc đối với mô hình.</p>

<p>Nhóm thuật toán này thường xây dựng cơ sở dữ liệu về dữ liệu mẫu và so sánh dữ liệu mới với cơ sở dữ liệu bằng cách sử dụng thước đo tương tự để tìm kết quả phù hợp nhất và đưa ra dự đoán. Khi đó trọng tâm được đặt vào đại diện của các thể hiện được lưu trữ như minh hoạ ở Hình 7.</p>

<p><img src="/post_image/instance-based-algorithms.jpg" alt="Hình ảnh" />
<strong>Hình 7: Instance-based Algorithms</strong></p>

<p>Các thuật toán dựa trên thực thể phổ biến nhất là:</p>

<ul>
<li><p>k-Nearest Neighbor (kNN – k láng giềng gần nhất)</p></li>

<li><p>Learning Vector Quantization (LVQ)</p></li>

<li><p>Locally Weighted Learning (LWL)</p></li>

<li><p>Self-Organizing Map (SOM)</p></li>
</ul>

<h2 id="c-thuật-toán-chuẩn-hoá-regularization-algorithms">c.   Thuật toán chuẩn hoá (Regularization Algorithms)</h2>

<p>Các thuật toán chuẩn hoá ra đời từ sự mở rộng các phương pháp đã có (điển hình là các phương pháp hồi quy) bằng cách xử phạt các mô hình dựa trên mức độ phức tạp của chúng. Việc ưu tiên các mô hình đơn giản hơn cũng tốt hơn trong việc khái quát hóa. Hình 8 tượng trưng cho ý tưởng của thuật toán chuẩn hoá.</p>

<p><img src="/post_image/regularization-algorithms.jpg" alt="Hình ảnh" />
<strong>Hình 8: Regularization Algorithms</strong></p>

<p>Các thuật toán chính quy phổ biến nhất là:</p>

<ul>
<li><p>Elastic Net</p></li>

<li><p>Least Absolute Shrinkage and Selection Operator (LASSO)</p></li>

<li><p>Least-Angle Regression (LARS)</p></li>

<li><p>Ridge Regression</p></li>
</ul>

<h2 id="d-thuật-toán-cây-quyết-định-decision-tree-algorithms">d.   Thuật toán cây quyết định (Decision Tree Algorithms)</h2>

<p>Đây là phương pháp xây dựng mô hình ra quyết định dựa trên các giá trị thực của những thuộc tính trong dữ liệu. Sự quyết định được rẽ nhánh trong cấu trúc cây cho đến khi quyết định dự đoán được đưa ra cho một mẫu nhất định như minh hoạ ở Hình 9. Phương pháp này được sử dụng trong việc huấn luyện dữ liệu cho bài toán phân lớp và hồi quy. Vì sự nhanh chóng, chính xác nên phương pháp này rất được ưa chuộng trong ML.</p>

<p><img src="/post_image/decision-tree-algorithm.jpg" alt="Hình ảnh" />
<strong>Hình 9: Decision Tree Algorithms</strong></p>

<p>Các thuật toán cây quyết định phổ biến nhất bao gồm:</p>

<ul>
<li><p>Chi-squared Automatic Interaction Detection (CHAID)</p></li>

<li><p>Classification và Regression Tree – CART</p></li>

<li><p>Conditional Decision Trees</p></li>

<li><p>C4.5 và C5.0</p></li>

<li><p>Decision Stump</p></li>

<li><p>Iterative Dichotomiser 3 (ID3)</p></li>

<li><p>M5</p></li>
</ul>

<h2 id="e-thuật-toán-bayes-bayesian-algorithms">e.   Thuật toán Bayes (Bayesian Algorithms)</h2>

<p>Đây là nhóm các thuật toán áp dụng Định lý Bayes cho bài toán phân loại và hồi quy.</p>

<p><img src="/post_image/bayessian-algorith.jpg" alt="Hình ảnh" />
<strong>Hình 10: Bayesian Algorithms</strong></p>

<p>Các thuật toán phổ biến nhất là:</p>

<ul>
<li><p>Averaged One-Dependence Estimators (AODE)</p></li>

<li><p>Bayesian Belief Network (BBN)</p></li>

<li><p>Bayesian Network (BN)</p></li>

<li><p>Gaussian Naive Bayes</p></li>

<li><p>Multinomial Naive Bayes</p></li>

<li><p>Naive Bayes</p></li>
</ul>

<h2 id="f-thuật-toán-phân-cụm-clustering-algorithms">f.   Thuật toán phân cụm (Clustering Algorithms)</h2>

<p>Tất cả các phương pháp đều sử dụng các cấu trúc vốn có trong dữ liệu để tổ chức tốt nhất dữ liệu thành các nhóm có mức độ phổ biến tối đa dựa vào trọng tâm (centroid) và thứ bậc (hierarchal) như thể hiện ở Hình 11.</p>

<p><img src="/post_image/clustering-algorithm.jpg" alt="Hình ảnh" />
<strong>Hình 11: Clustering Algorithms</strong></p>

<p>Các thuật toán phân cụm phổ biến nhất là:</p>

<ul>
<li><p>Expectation Maximisation (EM – cực đại hoá kỳ vọng)</p></li>

<li><p>Hierarchical Clustering</p></li>

<li><p>k-Means</p></li>

<li><p>k-Medians</p></li>
</ul>

<h2 id="g-các-thuật-toán-luật-kết-hợp-association-rule-learning-algorithms">g.   Các thuật toán luật kết hợp (Association Rule Learning Algorithms)</h2>

<p>Đây là những thuật toán sẽ rút trích ra các quy tắc giải thích tốt nhất mối quan hệ giữa các biến trong dữ liệu. Các quy tắc này có thể giúp khám phá ra các tính chất quan trọng và hữu ích trong các tập dữ liệu lớn và cao chiều trong thương mại cùng các lĩnh vực khác. Hình 12 minh hoạ cho ý tưởng của thuật toán luật kết hợp.</p>

<p><img src="/post_image/association-rule.jpg" alt="Hình ảnh" />
<strong>Hình 12: Association Rule Learning Algorithms</strong></p>

<p>Các thuật toán luật kết hợp phổ biến nhất là:</p>

<ul>
<li><p>Apriori algorithm</p></li>

<li><p>Eclat algorithm</p></li>

<li><p>FP-Growth algorithm</p></li>
</ul>

<h2 id="h-thuật-toán-mạng-nơron-nhân-tạo-artificial-neural-network-algorithms">h.   Thuật toán mạng nơron nhân tạo (Artificial Neural Network Algorithms)</h2>

<p>Mạng nơron nhân tạo là các mô hình được lấy cảm hứng từ cấu trúc và chức năng của mạng lưới thần kinh sinh học. Hình 13 minh hoạ cho một mạng truyền thẳng.
Nhóm thuật toán này có thể được sử dụng cho bài toán phân lớp và hồi quy với rất nhiều biến thể khác nhau cho hầu hết các vấn đề. Tuy nhiên, trong bài viết này mình chỉ trình bày các thuật toán cổ điển và phổ biến nhất:</p>

<ul>
<li><p>Back-Propagation (mạng lan truyền ngược)</p></li>

<li><p>Perceptron (Mạng lan truyền thẳng)</p></li>

<li><p>Multi-layer perceptron (Mạng truyền thẳng đa lớp)</p></li>

<li><p>Hopfield Network</p></li>

<li><p>Radial Basis Function Network (RBFN)</p></li>
</ul>

<p><img src="/post_image/neural-network-alg.jpg" alt="Hình ảnh" />
<strong>Hình 13: Artificial Neural Network Algorithms</strong></p>

<h2 id="i-thuật-toán-học-sâu-deep-learning-algorithms">i.   Thuật toán học sâu (Deep Learning Algorithms)</h2>

<p>Thực chất Deep Learning là một bản cập nhật hiện đại cho Artificial Neural Networks nhằm khai thác khả năng tính toán của máy tính, tuy nhiên vì sự phát triển lớn mạnh của chúng nên mình tách ra thành một nhóm riêng.</p>

<p>Deep Learning quan tâm đến việc xây dựng các mạng thần kinh lớn hơn, phức tạp hơn nhiều, và làm sao để khai thác hiệu quả các bộ dữ liệu lớn chứa rất ít dữ liệu đã được gán nhãn. Hình 14 minh hoạ cho ý tưởng của Deep learning.</p>

<p><img src="/post_image/deep-learning-alg.jpg" alt="Hình ảnh" />
<strong>Hình 14: Deep Learning Algorithms</strong></p>

<p>Các thuật toán học sâu phổ biến nhất là:</p>

<ul>
<li><p>Convolutional Neural Network (CNN)</p></li>

<li><p>Deep Belief Networks (DBN)</p></li>

<li><p>Deep Boltzmann Machine (DBM)</p></li>

<li><p>Stacked Auto-Encoders</p></li>
</ul>

<h2 id="j-nhóm-thuật-toán-giảm-chiều-dữ-liệu-dimensionality-reduction-algorithms">j.   Nhóm thuật toán Giảm chiều dữ liệu (Dimensionality Reduction Algorithms)</h2>

<p>Giống như các phương pháp phân cụm, giảm không gian tìm kiếm và khai thác cấu trúc vốn có trong dữ liệu nhưng theo cách không giám sát hoặc để tóm tắt hay mô tả dữ liệu sử dụng ít thông tin hơn là mục tiêu của nhóm phương pháp này. Hình 15 minh hoạ cho việc giảm chiều dữ liệu.</p>

<p>Điều này có thể hữu ích để trực quan hóa dữ liệu hoặc đơn giản hóa dữ liệu mà sau đó có thể được sử dụng trong phương pháp học có giám sát. Nhiều trong số các phương pháp này có thể được điều chỉnh để sử dụng trong phân lớp và hồi quy.</p>

<p><img src="/post_image/demension-reducion.jpg" alt="Hình ảnh" />
<strong>Hình 15: Dimensional Reduction Algorithms</strong></p>

<p>Các thuật toán Giảm chiều dữ liệu phổ biến như:</p>

<ul>
<li><p>Flexible Discriminant Analysis (FDA)</p></li>

<li><p>Linear Discriminant Analysis (LDA)</p></li>

<li><p>Mixture Discriminant Analysis (MDA)</p></li>

<li><p>Multidimensional Scaling (MDS)</p></li>

<li><p>Partial Least Squares Regression (PLSR)</p></li>

<li><p>Principal Component Analysis (PCA)</p></li>

<li><p>Principal Component Regression (PCR)</p></li>

<li><p>Projection Pursuit</p></li>

<li><p>Quadratic Discriminant Analysis (QDA)</p></li>

<li><p>Sammon Mapping</p></li>
</ul>

<h2 id="k-thuật-toán-tập-hợp-ensemble-algorithms">k.   Thuật toán tập hợp (Ensemble Algorithms)</h2>

<p>Ensemble methods là những phương pháp kết hợp các mô hình yếu hơn được huấn luyện độc lập và phần dự đoán của chúng sẽ được kết hợp theo một cách nào đó để đưa ra dự đoán tổng thể như minh họa ở Hình 16.</p>

<p>Nhóm thuật toán này khá mạnh và được nghiên cứu nhiều, đặc biệt là về cách để kết hợp các mô hình với nhau.</p>

<p><img src="/post_image/ensemble-alg.jpg" alt="Hình ảnh" />
<strong>Hình 16: Ensemble Algorithms</strong></p>

<p>Một số thuật toán phổ biến như:</p>

<ul>
<li><p>AdaBoost</p></li>

<li><p>Boosting</p></li>

<li><p>Bootstrapped Aggregation (Bagging)</p></li>

<li><p>Gradient Boosting Machines (GBM)</p></li>

<li><p>Gradient Boosted Regression Trees (GBRT)</p></li>

<li><p>Random Forest</p></li>

<li><p>Stacked Generalization (blending)</p></li>
</ul>

<h2 id="l-các-thuật-toán-khác">l.   Các thuật toán khác</h2>

<p>Còn rất nhiều các thuật toán khác không được liệt kê ở đây, chẳng hạn như Support Vector Machines (SVM), mình đang phân vân rằng liệu thuật toán này nên được đưa vào nhóm nào đó hay đứng một mình. Nếu dựa vào danh sách các biến thể và mức độ phát triển thì SVM có thể được tách thành một nhóm riêng – nhóm thuật toán sử dụng véctơ hỗ trợ.</p>

<p>Thêm vào đó, các thuật toán được hình thành từ các nhiệm vụ đặc biệt, hoăc các thuật toán từ những nhánh con đặc biệt của ML cũng không được liệt kê vào các nhóm, chẳng hạn như:</p>

<ul>
<li><p>Feature selection algorithms</p></li>

<li><p>Algorithm accuracy evaluation</p></li>

<li><p>Performance measures</p></li>
</ul>

<p>Có dịp mình sẽ bổ sung hoặc đề cập đến những thuật toán này ở một bài viết khác.</p>

<p>Mặc dù rất hữu ích (dựa vào nhóm, người dùng sẽ dễ dàng nhớ được bản chất của thuật toán) nhưng phương pháp phân nhóm này chưa hoàn hảo ở điểm có những thuật toán có thể phù hợp với nhiều danh mục như Learning Vector Quantization, vừa là phương pháp lấy cảm hứng từ mạng thần kinh (neural network), vừa là phương pháp dựa trên cá thể (instance-based). Hoặc là thuật toán có cùng tên mô tả bài toán và nhóm thuật toán như Hồi quy (Regression) và Phân cụm (Clustering). Đối với những trường hợp này ta có thể giải quyết bằng cách liệt kê các thuật toán hai lần hoặc bằng cách chọn nhóm một cách chủ quan. Để tránh trùng lặp các thuật toán và giữ cho mọi thứ đơn giản thì có lẽ chọn nhóm theo cách chủ quan sẽ phù hợp hơn.</p>

<p>Để giúp các bạn dễ nhớ cũng như tổng kết cho phần này mình đã vẽ một sơ đồ các thuật toán phân theo nhóm và sắp xếp theo alphabet, các bạn có thể xem thểm ở Hình 17 bên dưới.</p>

<p><img src="/post_image/machine-learning-branch.jpg" alt="Hình ảnh" />
<strong>Hình 17: Sơ đồ phân nhóm thuật toán theo sự tương đồng</strong></p>

<p>Hy vọng bài viết này sẽ mang lại hữu ích cho bạn đọc, nhất là giúp bạn có dược cái nhìn tổng quan về những gì hiện có và một số ý tưởng về cách liên kết các thuật toán với nhau.</p>

<p>Danh sách các nhóm và thuật toán được liệt kê trong bài viết chỉ đảm bảo được yếu tố phổ biến tuy nhiên sẽ không đầy đủ. Vậy nên nếu bạn biết thêm thuật toán hoặc nhóm nào chưa được liệt kê ở đây hoặc kể cả cách phân nhóm thuật toán khác, cũng như sau khi đọc mà các bạn có bất kỳ góp ý, câu hỏi giúp cải thiện bài viết tốt hơn, các bạn có thể để lại bình luận nhằm chia sẻ cùng mình và những bạn đọc khác nhé.</p>

<p>Tài liệu tham khảo:
A Tour of Machine Learning Algorithms by Jason Brownlee  in Understand Machine Learning Algorithms</p>

<p>Semi-Supervised Learning Tutorial by Xiaojin Zhu</p>

<p><a href="https://en.wikipedia.org/wiki/Outline_of_machine_learning#Machine_learning_algorithms">https://en.wikipedia.org/wiki/Outline_of_machine_learning#Machine_learning_algorithms</a></p>

<p>Top 10 algorithms in data mining by Xindong Wu · Vipin Kumar · J. Ross Quinlan · Joydeep Ghosh · Qiang Yang · Hiroshi Motoda · Geoffrey J. McLachlan · Angus Ng · Bing Liu · Philip S. Yu · Zhi-Hua Zhou · Michael Steinbach · David J. Hand · Dan Steinberg.</p>

<p>Cảm ơn các bạn đã theo dõi. Hẹn gặp bạn ở những bài viết tiếp theo.</p>

            </div>
        </article>
    </div>
    
<section id="sidebar" class="col-md-3">
<br/>
<div>
		<ul class="list-group" id="news-contents"></ul>
    <div id="calander">
	</div>
    </div>

  
   
  
  
  
  
  
  
  
  
 

</section>

    
	<hr>
  <footer class="footer">
  <div class="container text-center">
    
    <p class="copyright">
      
        &copy; 2020
        
          Phạm Duy Tùng Machine Learning Blog
        
      
     
    </p>
	</div>
  </footer>
    
    

    
      
    

    
      
      
      
        <script src="//cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
        
        
        
        <script src="//cdn.bootcss.com/highlight.js/9.15.8/languages/python.min.js"></script>
        <script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>
      
    
    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/skel/3.0.1/skel.min.js"></script>
     

   <script src="/js/jquery-3.3.1.min.js"></script>
   
    <script src="/js/bootstrap.min.js"></script>
      <script src="/js/util.js"></script>
      <script src="/js/main.js"></script>
     
    

    
      
        
      
    
	
    
    
      
<script async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


	  
	  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114911596-1"  data-cfasync="false"></script>
<script  data-cfasync="false">
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-114911596-1');
</script>
<script src="https://cdn.jsdelivr.net/npm/intersection-observer@0.5.1/intersection-observer.js"  data-cfasync="false"></script>
<script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@12.0.0/dist/lazyload.min.js"  data-cfasync="false"></script>
	   <script  type="text/javascript"  data-cfasync="false">

  function getcontent(){
 

   

             var myLazyLoad = new LazyLoad({
    elements_selector: ".lazy"
});
                }
            
			
			$(document).ready(function(){
      getcontent();
      
      const calander = document.querySelector('#calander');
      if (window.Worker) {
if (calander){
        var calanderworker = new Worker('js/worker.js');
        calanderworker.onmessage = (event) => { calander.innerHTML = event.data; }
        calanderworker.postMessage(calander.textContent);
      }
}
			}); 
</script>


  </body>
</html>

