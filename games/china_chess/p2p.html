<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="xiangqiboard.css" />
    <title>Phạm Duy Tùng | Cờ tướng online</title>



    
    <script src="/cdn-cgi/apps/head/btskv4UxB5kACRIO3BnCJ00RivE.js"></script><script defer="defer" async="async" src="https://www.googleoptimize.com/optimize.js?id=OPT-52RT2BV" type="e11606a2a81bee0389656eca-text/javascript"></script>
    <script type="application/ld+json">
        {
            "@context" : "http://schema.org",
            "@type" : "BlogPosting",
            "mainEntityOfPage": {
                 "@type": "WebPage",
                 "@id": "/"
            },
            "articleSection" : "blog",
            "name" : "Xây dựng chương trình AI đơn giản cho game cờ tướng",
            "headline" : "Xây dựng chương trình AI đơn giản cho game cờ tướng",
            "description" : "Hướng dẫn xây dựng chương trình AI đơn giản cho game cờ tướng sử dụng  minimax và cắt tỉa alpha, beta. Sử dụng html với javascript và package http-server của nodejs",
            "inLanguage" : "en",
            "author" : "alexblack2202@gmail.comPhạm Duy Tùng",
            "creator" : "alexblack2202@gmail.comPhạm Duy Tùng",
            "publisher": "alexblack2202@gmail.comPhạm Duy Tùng",
            "accountablePerson" : "alexblack2202@gmail.comPhạm Duy Tùng",
            "copyrightHolder" : "alexblack2202@gmail.comPhạm Duy Tùng",
            "copyrightYear" : "2021",
            "datePublished": "2021-08-12 00:19:00 &#43;0300 &#43;0300",
            "dateModified" : "2021-08-12 00:19:00 &#43;0300 &#43;0300",
            "url" : "/blog/2021-08-12-china_chess_alpha_beta_ai/",
            "wordCount" : "1861",
            "keywords" : [ "machine learning","ai","china chess","cờ tướng","minimax","alpha beta pruning","Blog" ]
        }
        </script>
    <title>Xây dựng chương trình AI đơn giản cho game cờ tướng</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="generator" content="Phạm Duy Tùng" />
    <meta property="fb:pages" content="1244186728962161" />
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-TileImage" content='/favicon/mstile.png'>
    <meta name="application-name" content="Phạm Duy Tùng Machine Learning Blog">
    <meta name="msapplication-tooltip" content="Blog ML của Phạm Duy Tùng và Đặng Thị Hằng">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <meta name="author" content="Phạm Duy Tùng">
    <meta name="description" content="Game AI cờ tướng">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@example" />
    <meta property="og:title" content="Game AI cờ tướng" />
    <meta property="og:description" content="Hướng dẫn xây dựng chương trình AI đơn giản cho game cờ tướng sử dụng  minimax và cắt tỉa alpha, beta. Sử dụng html với javascript và package http-server của nodejs" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="/blog/2021-08-12-china_chess_alpha_beta_ai/" /><meta property="article:published_time" content="2021-08-12T00:19:00&#43;03:00" />
    <meta property="article:modified_time" content="2021-08-12T00:19:00&#43;03:00" />
    <meta property="og:image" content="//images/logo.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta itemprop="name" content="Xây dựng chương trình AI đơn giản cho game cờ tướng">
    <meta itemprop="description" content="Hướng dẫn xây dựng chương trình AI đơn giản cho game cờ tướng sử dụng  minimax và cắt tỉa alpha, beta. Sử dụng html với javascript và package http-server của nodejs">
    <meta itemprop="datePublished" content="2021-08-12T00:19:00&#43;03:00" />
    <meta itemprop="dateModified" content="2021-08-12T00:19:00&#43;03:00" />
    <meta itemprop="wordCount" content="1861">
    <meta itemprop="keywords" content="machine learning,ai,china chess,cờ tướng,minimax,alpha beta pruning," />
    <link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/styles/xcode.min.css' rel='stylesheet' type='text/css' />
    <script type="e11606a2a81bee0389656eca-application/javascript">
    var doNotTrack = false;
    if (!doNotTrack) {
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-114911596-1', 'auto');
        
        ga('send', 'pageview');
    }
    </script>



    <style >
      .highlight {
  box-shadow: inset 0 0 2px 2px yellow;
}
    </style>
  </head>
  <body style="padding-top: 25px;">
    <main id="main" class="site-main main">
<section class="hero">
<!-- Large header banner -->
<div class="container">
  <div id="myBoard" style="width: 50%;float: left;"></div>
</div>
</section>
</main>
    

    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>

    <!-- Option 2: Separate Popper and Bootstrap JS -->
    <!--
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous"></script>
    -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <script src="xiangqiboard.js"></script>
    <!-- <script src="xiangqi.min.js"></script> -->
    <script src="https://cotuong.r.worldssl.net/js/xiangqi.js?v=33"></script>

    <script>
      // const config = {
      //     boardTheme: 'img/Xiangqi_board.svg',
      //     pieceTheme: 'img/{piece}.svg',
      //     orientation: 'white',
      //     position: 'start',
      //     showNotation: true
      // }
  
      // Xiangqiboard('#myBoard', config)

      let board = null;
let game = new Xiangqi();
let $status = $('#status');
let $fen = $('#fen');
let $pgn = $('#pgn');

function removeGreySquares () {
  $('#myBoard .square-2b8ce').removeClass('highlight');
}

function greySquare (square) {
  let $square = $('#myBoard .square-' + square);

  $square.addClass('highlight');
}

function onDragStart (source, piece, position, orientation) {
  // do not pick up pieces if the game is over
  if (game.game_over()) return false;

  if (piece.search(/^b/) !== -1) return false;
  // // only pick up pieces for the side to move
  // if ((game.turn() === 'r' && piece.search(/^b/) !== -1) ||
  //     (game.turn() === 'b' && piece.search(/^r/) !== -1)) {
  //   return false;
  // }
}


function minimaxRoot(depth, game, isMaximisingPlayer) {
  var newGameMoves = game.moves();
  var bestMove = -9999;
  var bestMoveFound;

  for(var i = 0; i < newGameMoves.length; i++) {
    var newGameMove = newGameMoves[i]
    game.move(newGameMove);
    var value = minimax(depth - 1, game, -INFINITY, INFINITY, !isMaximisingPlayer);
    game.undo();
    if(value >= bestMove) {
      bestMove = value;
      bestMoveFound = newGameMove;
    }
  }
  return bestMoveFound;
}

function minimax(depth, game, alpha, beta, isMaximisingPlayer) {

  if (depth === 0) {
    return -evaluateBoard(game.board());
  }

  var newGameMoves = game.moves();

  if (isMaximisingPlayer) {
    var bestMove = -9999;
    for (var i = 0; i < newGameMoves.length; i++) {
      game.move(newGameMoves[i]);
      bestMove = Math.max(bestMove, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));
      game.undo();
      alpha = Math.max(alpha, bestMove);
      if (beta <= alpha) {
        return bestMove;
      }
    }
    return bestMove;
  } else {
    var bestMove = 9999;
    for (var i = 0; i < newGameMoves.length; i++) {
      game.move(newGameMoves[i]);
      bestMove = Math.min(bestMove, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));
      game.undo();
      beta = Math.min(beta, bestMove);
      if (beta <= alpha) {
        return bestMove;
      }
    }
    return bestMove;
  }
}

function evaluateBoard(board) {
  var totalEvaluation = 0;
  for (var i = 0; i < 10; i++) {
    for (var j = 0; j < 9; j++) {
      totalEvaluation = totalEvaluation + getPieceValue(board[i][j], i ,j);
    }
  }
  return totalEvaluation;
}

function reverseArray(array) {
  return array.slice().reverse();
}

const INFINITY = 50000;

const pEvalRed =
[
[ 0,   3,   6,   9,  12,   9,   6,   3,   0],
        [18,  36,  56,  80, 120,  80,  56,  36,  18],
        [14,  26,  42,  60,  80,  60,  42,  26,  14],
        [10,  20,  30,  34,  40,  34,  30,  20,  10],
        [ 6,  12,  18,  18,  20,  18,  18,  12,   6],
        [ 2,   0,   8,   0,   8,   0,   8,   0,   2],
        [ 0,   0,  -2,   0,   4,   0,  -2,   0,   0],
        [ 0,   0,   0,   0,   0,   0,   0,   0,   0],
        [ 0,   0,   0,   0,   0,   0,   0,   0,   0],
        [ 0,   0,   0,   0,   0,   0,   0,   0,   0],
];

const pEvalBlack = reverseArray(pEvalRed);

const rEvalRed =
[
[ 14,  14,  12,  18,  16,  18,  12,  14,  14], 
        [ 16,  20,  18,  24,  26,  24,  18,  20,  16], 
        [ 12,  12,  12,  18,  18,  18,  12,  12,  12], 
        [ 12,  18,  16,  22,  22,  22,  16,  18,  12], 
        [ 12,  14,  12,  18,  18,  18,  12,  14,  12], 
        [ 12,  16,  14,  20,  20,  20,  14,  16,  12], 
        [  6,  10,   8,  14,  14,  14,   8,  10,   6], 
        [  4,   8,   6,  14,  12,  14,   6,   8,   4], 
        [  8,   4,   8,  16,   8,  16,   8,   4,   8], 
        [ -2,  10,   6,  14,  12,  14,   6,  10,  -2], 

];

const rEvalBlack = reverseArray(rEvalRed);

const nEvalRed =
[
[ 4,   8,  16,  12,   4,  12,  16,   8,   4], 
        [ 4,  10,  28,  16,   8,  16,  28,  10,   4],  
        [12,  14,  16,  20,  18,  20,  16,  14,  12],  
        [ 8,  24,  18,  24,  20,  24,  18,  24,   8],  
        [ 6,  16,  14,  18,  16,  18,  14,  16,   6],  
        [ 4,  12,  16,  14,  12,  14,  16,  12,   4],  
        [ 2,   6,   8,   6,  10,   6,   8,   6,   2],  
        [ 4,   2,   8,   8,   4,   8,   8,   2,   4],  
        [ 0,   2,   4,   4,  -2,   4,   4,   2,   0],  
        [ 0,  -4,   0,   0,   0,   0,   0,  -4,   0], 

];

const nEvalBlack = reverseArray(nEvalRed);

const cEvalRed =
[
[ 6,   4,   0, -10, -12, -10,   0,   4,   6], 
        [ 2,   2,   0,  -4, -14,  -4,   0,   2,   2], 
        [ 2,   2,   0, -10,  -8, -10,   0,   2,   2], 
        [ 0,   0,  -2,   4,  10,   4,  -2,   0,   0], 
        [ 0,   0,   0,   2,   8,   2,   0,   0,   0], 
        [-2,   0,   4,   2,   6,   2,   4,   0,  -2], 
        [ 0,   0,   0,   2,   4,   2,   0,   0,   0], 
        [ 4,   0,   8,   6,  10,   6,   8,   0,   4], 
        [ 0,   2,   4,   6,   6,   6,   4,   2,   0], 
        [ 0,   0,   2,   6,   6,   6,   2,   0,   0], 

];

const cEvalBlack = reverseArray(cEvalRed);

const bEvalRed =
[
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],

];

const bEvalBlack = reverseArray(bEvalRed);

const aEvalRed =
[
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],

];

const aEvalBlack = reverseArray(aEvalRed);

 kEvalRed =
[
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  2.0,  0.0,  0.0,  0.0, 0.0],
[0.0,  0.0,  0.0,  0.0,  4.0,  0.0,  0.0,  0.0, 0.0],

];

const kEvalBlack = reverseArray(kEvalRed);

function getPieceValue(piece, x, y) {
  if (piece === null) {
    return 0;
  }
  var getAbsoluteValue = function (piece, isRed, x ,y) {
    if (piece.type === 'p') { //chốt
      return 30 + ( isRed ? pEvalRed[x][y] : pEvalBlack[x][y] );
    } else if (piece.type === 'r') { //Xe
      return 600 +( isRed ? rEvalRed[x][y] : rEvalBlack[x][y] );
    } else if (piece.type === 'c') { //pháo
      return 285 +( isRed ? cEvalRed[x][y] : cEvalBlack[x][y] );
    } else if (piece.type === 'n') { // mã
      return 270 +( isRed ? nEvalRed[x][y] : nEvalBlack[x][y] );
    } else if (piece.type === 'b') { // tượng
      return 120 +( isRed ? bEvalRed[x][y] : bEvalBlack[x][y] );
    } else if (piece.type === 'a') { // sỹ
      return 120 +( isRed ? aEvalRed[x][y] : aEvalBlack[x][y] );
    } else if (piece.type === 'k') { // tướng
      return 6000 +( isRed ? kEvalRed[x][y] : kEvalBlack[x][y] );
    }
    throw "Unknown piece type: " + piece.type;
  };

  var absoluteValue = getAbsoluteValue(piece, piece.color === 'r', x ,y);
  return piece.color === 'r' ? absoluteValue : -absoluteValue;
}

function makeBestMove() {
  var bestMove = getBestMoveMaxi(game);
  game.move(bestMove);
  board.position(game.fen());
 // nuocCo.play();
  updateStatus();
}

function getBestMoveMaxi(game) {
  updateStatus();
  var depth = 4;
  var bestMove = minimaxRoot(depth, game, true);
  return bestMove;
}

function getBestMove(game) {

var newGameMoves = game.moves();
var bestMove = null;
// set đại một số âm vô hạn
var bestValue = -9999;

for (var i = 0; i < newGameMoves.length; i++) {
    var newGameMove = newGameMoves[i];
    game.move(newGameMove);

    var boardValue = -evaluateBoard(game.board())
    game.undo();
    if (boardValue > bestValue) {
        bestValue = boardValue;
        bestMove = newGameMove
    }
}

return bestMove;

};



function makeRandomMove () {
  let possibleMoves = game.moves();

  // game over
  if (possibleMoves.length === 0) return; // Không còn nước nào có thể đi, end game

  let randomIdx = Math.floor(Math.random() * possibleMoves.length); // bốc đại 1 nước đi trong danh sách các bước có thể đi
  game.move(possibleMoves[randomIdx]);
  board.position(game.fen());
}

function onDrop (source, target) {
  removeGreySquares();

  // see if the move is legal
  let move = game.move({
    from: source,
    to: target,
    promotion: 'q' // NOTE: always promote to a queen for example simplicity
  });

  // illegal move
  if (move === null) return 'snapback';

 // updateStatus();

  // make random legal move for black
  // window.setTimeout(makeRandomMove, 250);
  window.setTimeout(makeBestMove, 250);
}


function onMouseoverSquare (square, piece) {
  // get list of possible moves for this square
  let moves = game.moves({
    square: square,
    verbose: true
  });

  // exit if there are no moves available for this square
  if (moves.length === 0) return;

  // highlight the square they moused over
  greySquare(square);

  // highlight the possible squares for this piece
  for (let i = 0; i < moves.length; i++) {
    greySquare(moves[i].to);
  }
}

function onMouseoutSquare (square, piece) {
  removeGreySquares();
}


// update the board position after the piece snap
// for castling, en passant, pawn promotion
function onSnapEnd () {
  board.position(game.fen());
}

function updateStatus () {
  let status = '';

  let moveColor = 'Red';
  if (game.turn() === 'b') {
    moveColor = 'Black';
  }

  // checkmate?
  if (game.in_checkmate()) {
    status = 'Game over, ' + moveColor + ' is in checkmate.';
  }

  // draw?
  else if (game.in_draw()) {
    status = 'Game over, drawn position';
  }

  // game still on
  else {
    status = moveColor + ' to move';

    // check?
    if (game.in_check()) {
      status += ', ' + moveColor + ' is in check';
    }
  }

  $status.html(status);
  $fen.html(game.fen());
  $pgn.html(game.pgn());
}

let config = {
  draggable: true,
  position: 'start',
  onDragStart: onDragStart,
  onDrop: onDrop,
  onMouseoutSquare: onMouseoutSquare,
  onMouseoverSquare: onMouseoverSquare,
  onSnapEnd: onSnapEnd
};
board = Xiangqiboard('myBoard', config);

updateStatus();


let evtSource = new EventSource("https://cotuong.top/api/getFEN/14b35e82ccf2595e9f70853a96da8b5b");

evtSource.onmessage = function (e) {
  let newFEN = e.data;
  console.log(newFEN);
  if (newFEN != currentFEN) {
    currentFEN = game.fen();
    $.ajax({
      type: "POST",
      url: 'https://cotuong.top/api/updateFEN',
      data: {
        'ma-phong': '14b35e82ccf2595e9f70853a96da8b5b',
        'FEN': newFEN
      },
      dataType: 'text'
    });
    if (newFEN == game.fen()) {
      // my move
      board.position(newFEN, true);
      game.load(newFEN);
    } else {
      // opponent's move
      board.position(newFEN, true);
      game.load(newFEN);
      if (!game.fen().includes('resign')) {
        nuocCo.play();
      }
    }
  }
  updateStatus();
};
$('#resign').on('click', function() {
  game.load(game.fen() + ' resign');
  updateFenCode('14b35e82ccf2595e9f70853a96da8b5b');
  updateStatus();
});
  </script>
  </body>
 
 
</html>


<!-- https://github.com/maksimKorzh/wukong-xiangqi/blob/main/apps/puzzle_solver/engine/wukong.js-->